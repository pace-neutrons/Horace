classdef test_cluster_wrapper < TestCase & FakeJenkins4Tests
    % Test running using the parpool job dispatcher.

    properties
        stored_config = 'defaults';
    end

    methods
        function obj = test_cluster_wrapper(varargin)
            if ~exist('name', 'var')
                name = 'test_cluster_wrapper';
            end
            obj = obj@TestCase(name);
        end

        function clear_jenkins_var(obj)
            % clear fake Jenkins configuration, for is_jenkins routine
            % returning false
            clear_jenkins_var@FakeJenkins4Tests(obj);

            config_store.instance().clear_all();
            hc= hor_config;
            set(hc,obj.stored_config);
            hc.init_tests = true;
        end

        function set_up_fake_jenkins(obj)
            % set up fake Jenkins configuration, for is_jenkins routine
            % returning true
            set_up_fake_jenkins@FakeJenkins4Tests(obj,'test_jenkins_migration');

            hrc = hor_config;
            obj.stored_config = hrc.get_data_to_store();
        end

        function test_init_failed_cancelled(obj)
            [cluster,mf,clob] = obj.get_cluster_wrapper_tester(3);

            % build message framework to respond instead of a worker
            cs = mf.get_worker_init('MessagesParpool',1,3);
            css = mf.deserialize_par(cs);
            meR1 = MessagesFilebased(css);
            mc  = CancelledMessage('Test cancellation',...
                MException('MESSAGES_FRAMEWORK:cancelled','test cancellation'));
            meR1.send_message(0,mc );

            cluster = cluster.wait_started_and_report(1);
            assertEqual(cluster.status_name,'cancelled');
        end

        function test_init_failed_timeout(obj)
            [cluster,~,clob] = obj.get_cluster_wrapper_tester(3);

            cluster.cluster_startup_time =0;

            cluster = cluster.wait_started_and_report(0);
            assertEqual(cluster.status_name,'failed');
        end

        function test_cluster_init(obj)
            hrc = hor_config;
            hrc.saveable = false;
            hrc.init_tests = true;

            [cluster,mf,clob] = obj.get_cluster_wrapper_tester(3);

            % build message framework to respond instead of a worker
            cs = mf.get_worker_init('MessagesParpool',1,3);
            css = mf.deserialize_par(cs);
            meR1 = MessagesFilebased(css);

            cs = mf.get_worker_init('MessagesParpool',2,3);
            css = mf.deserialize_par(cs);
            meR2 = MessagesFilebased(css);

            cs = mf.get_worker_init('MessagesParpool',3,3);
            css = mf.deserialize_par(cs);
            meR3 = MessagesFilebased(css);

            % prepare fake data, usually generated by JobDispatcher
            jt = JETester();
            jeInit= jt.get_worker_init(false,false);
            worker_init_mess = {InitMessage(),InitMessage(),InitMessage()};
            worker_init_mess{1}.payload = 'a';
            worker_init_mess{2}.payload = 'b';
            worker_init_mess{3}.payload = 'c';

            meR1.send_message(0,'ready');
            cluster = cluster.wait_started_and_report(1);

            %--------------------------------------------------------------
            cluster = cluster.init_workers(jeInit,worker_init_mess);
            % send ready messages do disable cluster locking
            meR1.send_message(0,'started');
            %             meR2.send_message(1,'started'); % these are now sent to
            %             worker 1 and not tested here
            %             meR3.send_message(1,'started');

            [completed,failed,mess] = cluster.check_progress_from_messages();
            cluster.status = mess;
            assertEqual(cluster.status.mess_name,'started');
            assertFalse(completed)
            assertFalse(failed)
            %--------------------------------------------------------------
            % receive "starting" messages used to provide jeInit info to
            % each worker
            [ok,err,mess1]=meR1.receive_message(0,'starting');
            assertEqual(ok,MESS_CODES.ok,err);
            [ok,err,mess2]=meR2.receive_message(0,'starting');
            assertEqual(ok,MESS_CODES.ok,err);
            [ok,err,mess3]=meR3.receive_message(0,'starting');
            assertEqual(ok,MESS_CODES.ok,err);
            assertEqual(jeInit,mess1)
            assertEqual(jeInit,mess2)
            assertEqual(jeInit,mess3)


            % receive job init messages
            [ok,err,mess1]=meR1.receive_message(0,'init');
            assertEqual(ok,MESS_CODES.ok,err);
            [ok,err,mess2]=meR2.receive_message(0,'init');
            assertEqual(ok,MESS_CODES.ok,err);
            [ok,err,mess3]=meR3.receive_message(0,'init');
            assertEqual(ok,MESS_CODES.ok,err);

            assertEqual(worker_init_mess{1},mess1)
            assertEqual(worker_init_mess{2},mess2)
            assertEqual(worker_init_mess{3},mess3)

        end

        function test_cluster_init_on_fake_jenkins(obj)
            if is_jenkins() % do not run it on real Jenkins, it may mess
                % the whole Jenkins environment
                return;
            end
            obj.set_up_fake_jenkins();
            clearJenkinsSignature = onCleanup(@()clear_jenkins_var(obj));

            assertTrue(is_jenkins);
            % clear configuration from memory to ensure the configuration
            % will be rebuild as Jenkins configuration
            config_store.instance().clear_all();
            clOb = set_temporary_warning('off','HERBERT:config_store:default_configuration');

            obj.test_cluster_init();

            clear clearJenkinsSignature;
            assertFalse(is_jenkins);

        end

        function test_check_progress_disp_results(obj)

            [cluster,mf,clob] =  obj.get_cluster_wrapper_tester(0,'disp_prgrs');


            cs = mf.get_worker_init('MessagesFilebases',1,10);
            css = mf.deserialize_par(cs);
            meR = MessagesFilebased(css);

            meR.send_message(0,'starting');

            cluster = cluster.display_progress();
            assertEqual(cluster.log_value,'.');
            cluster = cluster.display_progress();
            assertEqual(cluster.log_value,'.');

            cluster = cluster.display_progress('unknown state');
            ref_string = sprintf('\n%s','**** unknown state    ');
            assertTrue(strncmp(cluster.log_value,ref_string,20));
            if verLessThan('matlab','9.1')
                CR =sprintf('\n');
            else
                CR =newline; % sprintf('\n');
            end

            [completed,failed,mess] = cluster.check_progress_from_messages();
            cluster.status = mess;
            assertFalse(completed)
            assertFalse(failed)

            cluster = cluster.display_progress();
            ref_string = ['***Job : ',mf.job_id,' : state: starting |',CR];
            assertEqual(cluster.log_value,ref_string);

            [completed,failed,mess] = cluster.check_progress_from_messages();
            cluster.status = mess;
            assertFalse(completed)
            assertFalse(failed)

            cluster = cluster.display_progress();
            assertEqual(cluster.log_value,'.');

            [completed,failed,mess] = cluster.check_progress_from_messages();
            cluster.status = mess;
            assertFalse(completed)
            assertFalse(failed)

            [completed,failed,mess] = cluster.check_progress_from_messages();
            cluster.status = mess;
            assertFalse(failed)
            assertFalse(completed);

            cluster = cluster.display_progress();
            assertEqual(cluster.log_value,'.');
            n_steps = cluster.log_wrap_length;
            for i=3:n_steps
                [completed,failed,mess] = cluster.check_progress_from_messages();
                cluster.status = mess;
                assertFalse(failed)
                assertFalse(completed);
                cluster = cluster.display_progress();
                assertEqual(cluster.log_value,'.');
            end
            [completed,failed,mess] = cluster.check_progress_from_messages();
            cluster.status = mess;
            assertFalse(failed)
            assertFalse(completed);

            cluster = cluster.display_progress();
            assertEqual(cluster.log_value,[CR,ref_string]);

            [completed,failed,mess] = cluster.check_progress_from_messages();
            cluster.status = mess;
            assertFalse(failed)
            assertFalse(completed);

            cluster = cluster.display_progress();
            assertEqual(cluster.log_value,'.');

            mess = LogMessage(1,50,0,[]);
            meR.send_message(0,mess);

            [completed,failed,mess] = cluster.check_progress_from_messages();
            cluster.status = mess;
            assertFalse(failed)
            assertFalse(completed);

            assertFalse(completed);
            cluster = cluster.display_progress();
            ref_string = [CR,'***Job : ',mf.job_id,' : state:  running |Step#1.00/50, Estimated time left:  Unknown | ',CR];
            assertEqual(cluster.log_value,ref_string);

            mess = LogMessage(2,50,1,[]);
            meR.send_message(0,mess);
            [completed,failed,mess] = cluster.check_progress_from_messages();
            cluster.status = mess;
            assertFalse(failed)
            assertFalse(completed);

            assertFalse(completed);
            cluster = cluster.display_progress();
            ref_string = ['***Job : ',mf.job_id,' : state:  running |Step#2.00/50, Estimated time left: 0.80(min)| ',CR];
            assertEqual(cluster.log_value,ref_string);

        end

        function test_utilises_logical_cores_when_n_workers_gt_physical_cores(~)
            [physical_cores, logical_cores] = get_num_cores();
            if physical_cores == logical_cores
                skipTest('No extra logical cores available, this test can do nothing')
            end
            msg_framework = MessagesFilebased('logical_cores_when_n_workers_gt');
            clust = ClusterParpoolWrapper();

            n_workers = physical_cores + 1;
            clust = clust.init(n_workers, msg_framework, ...
                hor_config().log_level);
            clob = onCleanup(@()finalize_all(clust));

            assertEqual(clust.n_workers, n_workers);

        end

        function test_num_workers_set_when_n_workers_lt_num_physical_cores(~)
            physical_cores = get_num_cores();
            msg_framework = MessagesFilebased('num_workers_set_when_n_workers_lt');
            clust = ClusterParpoolWrapper();

            n_workers = physical_cores - 1;
            clust = clust.init(n_workers, msg_framework, ...
                hor_config().log_level);
            clob = onCleanup(@()finalize_all(clust));

            assertEqual(clust.n_workers, n_workers);
        end

        function test_num_workers_set_when_n_workers_eq_num_physical_cores(~)
            physical_cores = get_num_cores();
            msg_framework = MessagesFilebased('num_workers_set_when_n_workers_eq');
            clob1 = onCleanup(@()finalize_all(msg_framework));

            clust = ClusterParpoolWrapper(0,msg_framework);
            clob = onCleanup(@()finalize_all(clust));

            clust = clust.init(physical_cores, msg_framework, ...
                hor_config().log_level);
            clob2 = onCleanup(@()finalize_all(clust));

            assertEqual(clust.n_workers, physical_cores);
        end

        function test_init_fails_if_n_workers_gt_num_logical_cores(~)
            [~, logical_cores] = get_num_cores();
            msg_framework = MessagesFilebased('init_fails_if_n_workers');
            clob1 = onCleanup(@()finalize_all(msg_framework));
            clust = ClusterParpoolWrapper();
            clob2 = onCleanup(@()finalize_all(clust));

            n_workers = logical_cores + 1;
            assertExceptionThrown(@() clust.init(n_workers, msg_framework, ...
                hor_config().log_level), ...
                'HERBERT:ClusterParpoolWrapper:invalid_argument');
            clob3 = onCleanup(@()finalize_all(clust));
        end
    end
    % keep userpath test methods.
    methods
        function test_set_user_env_if_matlabpath_set_with_more(obj)
            en = getenv('MATLABPATH');
            clEnv = onCleanup(@()setenv('MATLABPATH',en));
            pc = parallel_config;
            necessary_path = fileparts(which(pc.worker));
            this_path = fileparts(mfilename('fullpath'));
            setenv('MATLABPATH',strjoin({necessary_path,this_path},pathsep));

            [test_dir,clDir,ok]  = obj.make_dir_for_path('set_user_env_test_dir_plus_plus');
            if ~ok; return; end
            clPath = onCleanup(@()rmpath(test_dir));


            [cluster,~,clOb] = obj.get_cluster_wrapper_tester(3);
            path = cluster.common_env_var('MATLABPATH');
            paths = split(path,pathsep);

            assertTrue(obj.path_belongs(necessary_path,paths));
            assertFalse(obj.path_belongs(test_dir,paths));
            assertTrue(obj.path_belongs(this_path,paths));


            addpath(test_dir);

            cluster = cluster.add_user_path(pc);

            path = cluster.common_env_var('MATLABPATH');
            paths = split(path,pathsep);
            assertTrue(obj.path_belongs(test_dir,paths));
            assertTrue(obj.path_belongs(necessary_path,paths));
            assertTrue(obj.path_belongs(this_path,paths));

            % remove path first to avoid warinings
            clear clPath
        end

        function test_set_user_env_if_matlabpath_set(obj)

            en = getenv('MATLABPATH');
            clEnv = onCleanup(@()setenv('MATLABPATH',en));
            pc = parallel_config;
            necessary_path = fileparts(which(pc.worker));
            setenv('MATLABPATH',necessary_path);

            [test_dir,clDir,ok]  = obj.make_dir_for_path('set_user_env_test_dir_plus');
            if ~ok; return; end
            clPath = onCleanup(@()rmpath(test_dir));


            [cluster,~,clOb] = obj.get_cluster_wrapper_tester(3);
            path = cluster.common_env_var('MATLABPATH');
            paths = split(path,pathsep);
            assertFalse(obj.path_belongs(test_dir,paths));
            assertTrue(obj.path_belongs(necessary_path,paths));

            addpath(test_dir);

            cluster = cluster.add_user_path(pc);

            path = cluster.common_env_var('MATLABPATH');
            paths = split(path,pathsep);
            assertTrue(obj.path_belongs(test_dir,paths));
            assertTrue(obj.path_belongs(necessary_path,paths));

            % remove path first to avoid warinings
            clear clPath
        end

        function test_set_user_env(obj)

            en = getenv('MATLABPATH');
            clEnv = onCleanup(@()setenv('MATLABPATH',en));
            pc = parallel_config;
            necessary_path = fileparts(which(pc.worker));

            [test_dir,clDir,ok]  = obj.make_dir_for_path('set_user_env_test_dir');
            if ~ok; return; end
            clPath = onCleanup(@()rmpath(test_dir));

            [cluster,~,clOb] = obj.get_cluster_wrapper_tester(3);
            path = cluster.common_env_var('MATLABPATH');
            paths = split(path,pathsep);
            assertTrue(obj.path_belongs(necessary_path,paths));
            assertFalse(obj.path_belongs(test_dir,paths));

            addpath(test_dir);

            cluster = cluster.add_user_path(pc);

            path = cluster.common_env_var('MATLABPATH');
            paths = split(path,pathsep);

            assertTrue(obj.path_belongs(test_dir,paths));
            assertTrue(obj.path_belongs(necessary_path,paths));

            % remove path first to avoid warinings
            clear clPath
        end
    end
    methods(Access= protected)
        function is = path_belongs(~,folder,path)
            if ispc()
                belongs = cellfun(@(x)strcmpi(x,folder),path);
                is = any(belongs);
            else
                is = ismember(folder,path);
            end
        end
        function [test_dir,clDir,ok]  = make_dir_for_path(~,dir_name)
            test_dir = fullfile(tmp_dir,dir_name);
            ok = mkdir(test_dir);
            if ~ok
                skipTest('test_cluster_wrapper:test_set_user_env. Can not create test folder. Issue with access rights?')
            end
            clDir = onCleanup(@()rmdir(test_dir,'s'));

        end
        function [cluster,mf,clob] =  get_cluster_wrapper_tester(~,n_workers,fmw_init)
            % Inputs:
            % n_workers -- number of test workers
            % fmw_init  -- information on framework initialization

            if nargin < 3
                fii = iMessagesFramework.build_worker_init(tmp_dir, ...
                    'test_init_failed_timeout', 'MessagesFilebased', 0, n_workers,'test_mode');
            else
                fii = fmw_init;
            end

            mf = MessagesFilebased(fii);
            cluster = ClusterWrapperTester(n_workers,mf);
            clob = onCleanup(@()finalize_all(cluster));

        end
    end
end
