classdef JETesterWithData < JobExecutor
    % Class used to test job dispatcher functionality
    % when data messages are exchenged doing synchronized
    % send-reduce cycle with barrier between send and reduce.
    %
    %

    properties(Access = private)
        is_finished_ = false;
        build_data = false;
        n_step;
        buffer;
        partial_data_cache;
        log_step;
        log_step_count;
    end

    methods
        function je = JETesterWithData()
        end

        function  [obj,mess] = init(obj,fbMPI,intercomm,init_message,is_tested)
            [obj,mess] = init@JobExecutor(obj,fbMPI,intercomm,init_message,is_tested);
            if ~isempty(mess)
                return;
            end

            job_par = obj.common_data_;
            obj.partial_data_cache = zeros(1,obj.n_steps);
            obj.n_step = 0;
            dbs = job_par.data_buffer_size;
            obj.buffer = ones(1,dbs);
            if obj.n_steps > 10
                obj.log_step = floor(obj.n_steps/10);
            else
                obj.log_step = 1;
            end
            obj.log_step_count = 0;
        end

        function obj=do_job(obj)
            % Test do_job method implementation for testing purposes
            %
            % the particular JobDispatcher should write its own method
            % keeping the same meaning for the interface
            %
            % Input parameters:
            % control_struct -- a structure, containing job
            %                   parameters.
            % this structure is generated by JobDispatcher.send_jobs method
            % by dividing array or cellarray of input parameters between
            % workers.
            %
            % this particular implementation writes files according to template,
            % provided in test_job_dispatcher.m file
            %aa= input('enter_something')

            task_num = obj.labIndex;

%             disp('****************************************************');
%             fprintf('labN: %d Do_job at step %d#%d, processing datablock of %d\n',...
%                 task_num,obj.n_step+1,obj.n_steps,numel(obj.buffer));

            obj=obj.gen_data(task_num);
        end

        function  obj=reduce_data(obj)
            % always arithmetic progression on number of steps.
            obj.task_outputs = sum(obj.partial_data_cache);
            obj.n_step = obj.n_step+1;
            if obj.n_step > obj.n_steps
                obj.is_finished_ = true;
            end

        end

        function ok = is_completed(obj)
            ok = obj.is_finished_;
        end

        function obj=gen_data(obj,task_num)
            if task_num == 1
                all_mess = obj.mess_framework.receive_all('all','data');
                accum = 0;
                for i=1:numel(all_mess)
                    accum = accum+sum(all_mess{i}.payload)/numel(all_mess{i}.payload);
                end
                accum = accum/numel(all_mess); % should give step number
                obj.partial_data_cache(obj.n_step+1) = accum;
            else
                me = DataMessage();
                me.payload = obj.buffer*obj.n_step;
                obj.mess_framework.send_message(1,me);
                obj.partial_data_cache(obj.n_step+1) = obj.n_step;
            end

            obj.log_step_count = obj.log_step_count+1;

            if obj.log_step_count >=obj.log_step
                mis = MPI_State.instance();
                mis.do_logging(obj.n_step,obj.n_steps)
                obj.log_step_count=0;
            end
        end
    end

end
