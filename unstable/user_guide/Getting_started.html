<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Getting started &mdash; Horace  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js?v=b3ba4146"></script>
        <script src="../_static/doctools.js?v=888ff710"></script>
        <script src="../_static/sphinx_highlight.js?v=4825356b"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Horace GUI" href="Horace_GUI.html" />
    <link rel="prev" title="User’s Guide" href="../User_guide.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Horace
              <img src="../_static/150px-Quintus_Horatius_Flaccus.jpg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../Introduction.html">Introduction and Setup</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../User_guide.html">User’s Guide</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Getting started</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#creating-an-sqw-file">Creating an SQW file</a></li>
<li class="toctree-l3"><a class="reference internal" href="#data-visualisation">Data visualisation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#basic-data-manipulation">Basic data manipulation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#simulations">Simulations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fitting">Fitting</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Horace_GUI.html">Horace GUI</a></li>
<li class="toctree-l2"><a class="reference internal" href="Advanced_use.html">Advanced use</a></li>
<li class="toctree-l2"><a class="reference internal" href="Resolution_convolution.html">Resolution Convolution</a></li>
<li class="toctree-l2"><a class="reference internal" href="Interfacing_with_other_programs.html">Interfacing with other programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="Example_scripts.html">Example scripts</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Horace_manual.html">Horace Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Citing.html">Citing Horace</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Developers.html">For Developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Contributing.html">Contributing to Horace</a></li>
<li class="toctree-l1"><a class="reference internal" href="../API_Reference.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../General_disclaimer.html">General disclaimer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Privacy_policy.html">Privacy Policy</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Horace</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../User_guide.html">User’s Guide</a></li>
      <li class="breadcrumb-item active">Getting started</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/user_guide/Getting_started.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="getting-started">
<h1>Getting started<a class="headerlink" href="#getting-started" title="Permalink to this heading"></a></h1>
<p>In order to get going with Horace we suggest that you take a little time to familiarise yourself with the program. To
aid this we have created the following step-by-step guide that takes you through the process of converting SPE files
into a format useable by Horace, and then shows you how to do different kinds of plot, how to manipulate your data, and
finally how to simulate and fit your data. To do this we will refer to the demonstration files included in</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">C</span><span class="p">:</span><span class="o">\</span><span class="n">mprogs</span><span class="o">\</span><span class="n">Horace</span><span class="o">\</span><span class="nb">demo</span><span class="o">\</span>
</pre></div>
</div>
<p>which relate to a real experiment to investigate spin excitations in Fe using the MAPS spectrometer at ISIS.</p>
<p>Before starting you must first run the <code class="docutils literal notranslate"><span class="pre">setup_demo_data</span></code> function from the <code class="docutils literal notranslate"><span class="pre">demo</span></code> folder which will take a few
minutes to generate a number of <code class="docutils literal notranslate"><span class="pre">.nxspe</span></code> files which will be used during the demo.</p>
<section id="creating-an-sqw-file">
<h2>Creating an SQW file<a class="headerlink" href="#creating-an-sqw-file" title="Permalink to this heading"></a></h2>
<p>The first step in using Horace is to make your dataset from all of your relevant SPE files. How this works depends
somewhat on the properties of your computer, specifically the amount of memory available, and is dealt with
<a class="reference internal" href="../introduction/Download_and_setup.html#system-requirements"><span class="std std-ref">here</span></a>.
On most machines (those with &lt;10GB RAM) the dataset is written to a new file with the extension <code class="docutils literal notranslate"><span class="pre">.sqw</span></code>, and
intermediate <code class="docutils literal notranslate"><span class="pre">.tmp</span></code> files, which contain axes projection information, are written as Horace combines the data. Once you
have created your SQW file and are happy with it then you can delete these intermediate <code class="docutils literal notranslate"><span class="pre">.tmp</span></code> files if you wish, although
it is generally a good idea to keep for a few days them unless disk space is a problem for you, in case you wish to
re-generate your SQW file. For special cases where large amounts of memory are available then the creation of <code class="docutils literal notranslate"><span class="pre">.tmp</span></code> files
is unnecessary and the SQW file can be created directly. This latter case is dealt with in the section of this manual
detailing <a class="reference internal" href="Advanced_use.html#advanced-use"><span class="std std-ref">advanced use</span></a>, for the rest of the following we shall assume you
are running a machine with less memory.</p>
<p>In addition to your data there is one other file that is required – the parameter file for the instrument that you used
to collect the data. This file has the extension <code class="docutils literal notranslate"><span class="pre">.par</span></code>, and is <strong>not</strong> the same as a <code class="docutils literal notranslate"><span class="pre">.phx</span></code> file. If you try to use a <code class="docutils literal notranslate"><span class="pre">.phx</span></code>
file with Horace you will just get an error message! The <code class="docutils literal notranslate"><span class="pre">.par</span></code> file for the instrument you used to generate your data can
be obtained from the instrument scientist. It is important that you have the correct version of this file for the
configuration of the instrument as it was when you used it (much like for the PHX file).</p>
<p>Let’s now run through a simple example. To do this we’ll need some example SPE files and a PAR file. The script file
containing all of the commands described below is located in</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">C</span><span class="p">:</span><span class="o">\</span><span class="n">mprogs</span><span class="o">\</span><span class="n">Horace</span><span class="o">\</span><span class="nb">demo</span><span class="o">\</span><span class="n">demo_make_sqw_fe</span><span class="p">.</span><span class="n">m</span>
</pre></div>
</div>
<p>First we need to tell Horace where the SPE files are, so we write:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">indir</span><span class="p">=</span><span class="s">&#39;C:\mprogs\Horace\demo\&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>We also need to know where the PAR file is, and where the SQW file that we’re making is going to go:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">par_file</span><span class="p">=</span><span class="s">&#39;C:\mprogs\Horace\demo\demo_par.par&#39;</span><span class="p">;</span>
<span class="n">sqw_file</span><span class="p">=</span><span class="s">&#39;C:\mprogs\Horace\demo\demo_fe_sqw.sqw;&#39;</span>
</pre></div>
</div>
<p>Next we need to specify the (fixed) incident energy that was used and the geometry of the spectrometer. In this case all
of the data were taken using Ei=787meV on a direct geometry spectromter, so we have:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">efix</span><span class="p">=</span><span class="mi">787</span><span class="p">;</span>
<span class="n">emode</span><span class="p">=</span><span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
<p>If we were using an indirect geometry spectrometer then we would have written</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">emode</span><span class="p">=</span><span class="mi">2</span><span class="p">;</span>
</pre></div>
</div>
<p>We cannot combine data from different spectrometers, so <code class="docutils literal notranslate"><span class="pre">emode</span></code> is always 1 or 2.</p>
<p>If we had used multiple incident energies then we would have made <code class="docutils literal notranslate"><span class="pre">efix</span></code> a vector whose length was the number of SPE
files we wish to combine and whose elements were the incident energy for each SPE file.</p>
<p>We now need to tell Horace the lattice parameters of the sample:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">alatt</span><span class="p">=[</span><span class="mf">2.87</span><span class="p">,</span><span class="mf">2.87</span><span class="p">,</span><span class="mf">2.87</span><span class="p">];</span>
<span class="n">angdeg</span><span class="p">=[</span><span class="mi">90</span><span class="p">,</span><span class="mi">90</span><span class="p">,</span><span class="mi">90</span><span class="p">];</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">alatt</span></code>, which can be a row vector or a column vector, gives the lattice parameters <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>, and <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">angdeg</span></code>, which can also be a row vector or a column vector, gives the lattice angles <code class="docutils literal notranslate"><span class="pre">alpha</span></code>, <code class="docutils literal notranslate"><span class="pre">beta</span></code>, and <code class="docutils literal notranslate"><span class="pre">gamma</span></code>.</p></li>
</ul>
<p>Then we need to specify the orientation of the crystal with respect to the incident beam and the spectrometer. We do
this by specifying the scattering plane with two orthogonal vectors:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">u</span><span class="p">=[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">];</span>
<span class="n">v</span><span class="p">=[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">];</span>
</pre></div>
</div>
<p>The vector <strong>u</strong> defines the direction in the <strong>(h,k,l)</strong> frame of the incident beam (so in the above example the
crystal’s (1,0,0) direction is parallel to the incident beam). The vector <strong>v</strong> may be perpendicular to <strong>u</strong>
(although it does not have to be) and lies in the equatorial plane of the spectrometer (i.e. the horizontal plane on
MERLIN and MAPS). Thus the cross product of <strong>u</strong> and <strong>v</strong> should point up/down the sample stick.</p>
<p>If after your experiment you realise that your crystal was not aligned how you thought it was, all is not lost! Horace
allows you to specify some <em>virtual goniometer</em> angles which tell the program how to convert the supplied (incorrect)
co-ordinate frame <strong>u</strong> and <strong>v</strong> to the real one. Of course you should make every effort to ensure your sample
was correctly aligned, in which case you write</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">omega</span><span class="p">=</span><span class="mi">0</span><span class="p">;</span><span class="n">dpsi</span><span class="p">=</span><span class="mi">0</span><span class="p">;</span><span class="n">gl</span><span class="p">=</span><span class="mi">0</span><span class="p">;</span><span class="n">gs</span><span class="p">=</span><span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>The definitions of these angles are best described with reference to the picture below:</p>
<a class="reference internal image-reference" href="../_images/Gonio_angle_definitions.jpg"><img alt="Virtual goniometer angle definitions" src="../_images/Gonio_angle_definitions.jpg" style="width: 300px;" /></a>
<p>In this diagram the nominal vectors <strong>u</strong> and <strong>v</strong> are those supplied to Horace, whereas <strong>u’</strong> and
<strong>v’</strong> are the actual vectors. <code class="docutils literal notranslate"><span class="pre">gl</span></code> and <code class="docutils literal notranslate"><span class="pre">gs</span></code> deal with misorientation about axes which lie in the
spectrometer’s equatorial plane, whereas <code class="docutils literal notranslate"><span class="pre">dpsi</span></code> deals with misorientations about a vector perpendicular to this
plane. <code class="docutils literal notranslate"><span class="pre">omega</span></code> is the angle by which the <code class="docutils literal notranslate"><span class="pre">gs</span></code> axis is rotated compared to the nominal vector <strong>u</strong>.</p>
<p>In principle this means that you could put a single crystal with unknown orientation into the spectrometer and conduct
your experiment. However this is not a good idea, because the direction about which you rotate your crystal may not be
the optimum for you to get all of the data that you want to, since the detectors do not cover <span class="math notranslate nohighlight">\(4 \pi\)</span> steradians.</p>
<p>Now we’ve told Horace all about the setup of the spectrometer we can go on to specify how our experiment was conducted
and which SPE files will contribute to our dataset.</p>
<p>Suppose, as is the case here, we want to combine 24 SPE files, and that the angle psi was different for each
one. <code class="docutils literal notranslate"><span class="pre">psi</span></code> is a vector, which in this case has 24 elements. We could write it out explicitly, however in our example
we took data in equal steps of psi between 0 degrees and -23 degrees (1 degree steps), so we can use a Matlab trick:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">nfiles</span><span class="p">=</span><span class="mi">24</span><span class="p">;</span>
<span class="nb">psi</span><span class="p">=</span><span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">(</span><span class="n">nfiles</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="n">nfiles</span><span class="p">);</span>
</pre></div>
</div>
<p>Horace needs to know the name of all 24 SPE files. To do this they are combined into a single object – a cell array,
which is a Matlab data format you can read about in the Matlab help. In this case each element of the cell array is a
string which specifies the location of our SPE files. We could write this out explicitly, however in this example the
SPE files are numbered sequentially, so we can take another shortcut:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">spe_file</span><span class="p">=</span><span class="nb">cell</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">nfiles</span><span class="p">);</span>
<span class="k">for</span><span class="w"> </span><span class="nb">i</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="nb">length</span><span class="p">(</span><span class="nb">psi</span><span class="p">)</span>
<span class="w">  </span><span class="n">spe_file</span><span class="p">{</span><span class="nb">i</span><span class="p">}=[</span><span class="n">indir</span><span class="p">,</span><span class="s">&#39;MAP&#39;</span><span class="p">,</span><span class="nb">num2str</span><span class="p">(</span><span class="mi">11012</span><span class="o">+</span><span class="p">(</span>2<span class="nb">i</span><span class="p">)),</span><span class="s">&#39;.SPE&#39;</span><span class="p">];</span>
<span class="k">end</span>
</pre></div>
</div>
<p>(Note that the extension <code class="docutils literal notranslate"><span class="pre">.spe;1</span></code> is not usual, normally it would be something like <code class="docutils literal notranslate"><span class="pre">.spe</span></code> or <code class="docutils literal notranslate"><span class="pre">.SPE</span></code>. Notice that
it does matter whether you write the extension in lower or upper case on Windows. We have found that it does matter on,
for example, Red Hat Linux).</p>
<p>The first line creates an empty cell array the right size to take our 24 file strings. Inside the <code class="docutils literal notranslate"><span class="pre">for</span></code> loop the ith
element of the cell array is a string specifying where ith SPE file. So the 5th element of the cell array <code class="docutils literal notranslate"><span class="pre">spe_file</span></code>
is:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">spe_file</span><span class="p">{</span><span class="mi">5</span><span class="p">}=</span><span class="s">&#39;C:\mprogs\Horace\demo\demo_data\MAP11022.SPE&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>We are now ready to make our SQW file! This is done by a single function:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">gen_sqw</span><span class="p">(</span><span class="n">spe_file</span><span class="p">,</span><span class="n">par_file</span><span class="p">,</span><span class="n">sqw_file</span><span class="p">,</span><span class="n">efix</span><span class="p">,</span><span class="n">emode</span><span class="p">,</span><span class="n">alatt</span><span class="p">,</span><span class="n">angdeg</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="nb">psi</span><span class="p">,</span><span class="n">omega</span><span class="p">,</span><span class="n">dpsi</span><span class="p">,</span><span class="n">gl</span><span class="p">,</span><span class="n">gs</span><span class="p">);</span>
</pre></div>
</div>
<p>If everything has worked then the Matlab command window will show text like this, which will be updated when each
successive SPE file is read from the disk.</p>
<a class="reference internal image-reference" href="../_images/Screenshot1.png"><img alt="The command window display during gen_sqw" src="../_images/Screenshot1.png" style="width: 500px;" /></a>
<p>(Note that the above screenshot was created when processing a larger number of files from the same dataset as has been
used for this demo. The only practical difference this makes is to the size of errorbars in 1d cuts, the time taken to
process the data, and some of the on-screen printouts.)</p>
<p>Further through the process you should see something like this:</p>
<a class="reference internal image-reference" href="../_images/Screenshot2.png"><img alt="The command window display during gen_sqw" src="../_images/Screenshot2.png" style="width: 500px;" /></a>
<p>Notice that this was run on a Linux machine, hence the different style of directory name and appearance of the Matlab window.</p>
<p>Horace will now run for some time generating the SQW file. This can be quite a long time, and depends quite a lot on how
much memory your computer has and its processor speed. It is probably best at this stage just to leave your computer to
run and go for a coffee! As a rough guide 150 SPE files, each of 105MB, would be combined on a machine with 4GB of RAM
(with its <a class="reference internal" href="../introduction/Download_and_setup.html#system-requirements"><span class="std std-ref">3GB switch enabled</span></a>) and a speed of 2.5GHz in
about 2 hours.</p>
<p>For this demo the data files have purposely been made much smaller (by using only the low angle detector banks on MAPS,
and by only including a limited number of energy bins in the SPE files). Each SPE file is about 18MB, and thus it takes
about 8 minutes to process all of the data. If all is well messages will be frequently printed to the Matlab command
window to let you know the status of your SQW file generation.</p>
</section>
<section id="data-visualisation">
<h2>Data visualisation<a class="headerlink" href="#data-visualisation" title="Permalink to this heading"></a></h2>
<p>Now that we’ve made our SQW file the next step is to see what the data look like. The first thing to do is to tell the
program where the SQW file is located:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">data_source</span><span class="p">=</span><span class="s">&#39;C:\mprogs\Horace\demo\ demo_fe_sqw.sqw&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>which is of course the location of the SQW file we created in the previous section.</p>
<p>Now we have to define the projection axes for our data visualization. The projection information is contained in a
structure array, which in this case we are calling <code class="docutils literal notranslate"><span class="pre">proj_100</span></code>. Two of the fields in this structure array are
vectors. These are chosen to define the normalization (so they must be unit vectors). There are also other pieces of
information that can be provided about the projection, but these will be dealt with later. So we have:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">proj_100</span><span class="p">.</span><span class="n">u</span><span class="p">=[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">];</span>
<span class="n">proj_100</span><span class="p">.</span><span class="n">v</span><span class="p">=[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">];</span>
</pre></div>
</div>
<p>You can choose any (orthogonal) set of axes to make cuts and visualise your data - you are not limited to the projection
axes of the crystal with respect to the spectrometer. This is one of the main advantages of using Horace to visualise
your data!</p>
<p>Another piece of projection information that we need to know is whether the projection axes are normalised in Angstroms
or reciprocal lattice units. There are 3 letters (for the 3 projection axes, the third of which is the cross product of
the other two), <code class="docutils literal notranslate"><span class="pre">'r'</span></code> is used for reciprocal lattice units and <code class="docutils literal notranslate"><span class="pre">'a'</span></code> is used for angstroms.</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">proj_100</span><span class="p">.</span><span class="n">type</span><span class="p">=</span><span class="s">&#39;rrr&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>Finally, we need to know if we are defining our projection axes relative to some offset. This vector has 4 components,
since we could offset in energy as well as the 3 components of <strong>Q</strong>:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">proj_100</span><span class="p">.</span><span class="n">uoffset</span><span class="p">=[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">];</span>
</pre></div>
</div>
<p>We now have all the information needed to make any kind of cut we like. Let’s start by making a 2D slice:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">w100_2</span><span class="p">=</span><span class="n">cut_sqw</span><span class="w"> </span><span class="p">(</span><span class="n">data_source</span><span class="p">,</span><span class="n">proj_100</span><span class="p">,[</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">],</span><span class="mf">0.05</span><span class="p">,[</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">500</span><span class="p">]);</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/Screenshot_cut1.png"><img alt="Matlab window during cutting" src="../_images/Screenshot_cut1.png" style="width: 500px;" /></a>
<p>This slice has as its axes (0,1,0) and energy. The first two arguments in the function <code class="docutils literal notranslate"><span class="pre">cut_sqw</span></code> are where the data is
on the computer, and the details of the projections. The next four arguments give either the integration range or the
step size of each component of Q and energy. In this example we are integrating between -0.2 and 0.2 r.l.u. in the
(1,0,0) component, and between -0.2 and 0.2 in the (0,0,1) component. The slice axes are (0,0,1) whose step size is 0.05
r.l.u., and energy whose step size is the minimum possible (this would have been specified when you Homered your
data). Notice that we’ve specified the energy step size differently from the (0,0,1) step size. If a scalar is used then
the whole range of data along that axis will be plotted. If a vector of the form [low,step,high] is used then only data
within the range low -&gt; high will be plotted, with step size given by <code class="docutils literal notranslate"><span class="pre">step</span></code>.</p>
<p>We don’t yet get a plot of this slice. All we’ve done here is create an <code class="docutils literal notranslate"><span class="pre">sqw</span></code> object which contains the relevant
information. However to plot it all we have to do is write:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="nb">plot</span><span class="p">(</span><span class="n">w100_2</span><span class="p">);</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/Screenshot_cut2.png"><img alt="2d cut from the data" src="../_images/Screenshot_cut2.png" style="width: 301px;" /></a>
<p>The ranges of the axes are not quite right, but we can easily change that:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">lx</span><span class="w"> </span><span class="s">1</span><span class="w"> </span><span class="s">3</span>
<span class="n">ly</span><span class="w"> </span><span class="s">0</span><span class="w"> </span><span class="s">150</span>
<span class="n">lz</span><span class="w"> </span><span class="s">0</span><span class="w"> </span><span class="s">1</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/Screenshot_cut3.png"><img alt="2d cut from data, with plot axes modified" src="../_images/Screenshot_cut3.png" style="width: 301px;" /></a>
<p>This makes the horizontal axis go from 1 to 3, the vertical axis from 0 to 150, and the colour scale go from 0 to 1.</p>
<p>If we wanted to make a 1D cut through the data then the syntax is exactly the same. For example:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">w100_1</span><span class="p">=</span><span class="n">cut_sqw</span><span class="w"> </span><span class="p">(</span><span class="n">data_source</span><span class="p">,</span><span class="n">proj_100</span><span class="p">,[</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">],</span><span class="mf">0.05</span><span class="p">,[</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">],[</span><span class="mi">60</span><span class="p">,</span><span class="mi">70</span><span class="p">]);</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">w100_1</span><span class="p">);</span>
<span class="n">lx</span><span class="w"> </span><span class="s">1</span><span class="w"> </span><span class="s">3</span>
<span class="n">ly</span><span class="w"> </span><span class="s">0.2</span><span class="w"> </span><span class="s">0.8</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/Screenshot_1dcut.png"><img alt="1d cut" src="../_images/Screenshot_1dcut.png" style="width: 301px;" /></a>
<p>would give us a cut along the (0,k,0) axis at a constant energy of 65meV.</p>
<p>3D slices are also possible. To visualize these the “sliceomatic” program is used. When the plot command is executed a
GUI is launched that allows you to plot multiple slices through the data. For example you could plot the same slice with
x and y axes of (1,0,0) and (0,1,0) at a range of energies.</p>
<a class="reference internal image-reference" href="../_images/Screenshot_3dslice.png"><img alt="Sliceomatic in action" src="../_images/Screenshot_3dslice.png" style="width: 501px;" /></a>
<p>It is possible to save your cuts / slices to be viewed again later. This can be done very simply in two ways. If you add
an extra argument to the end of <code class="docutils literal notranslate"><span class="pre">cut_sqw</span></code>, then the cut data are sent to a file. For our 1D cut above this would be:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">cut_file</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&#39;C:\mprogs\Horace\demo\plots\w100_1.sqw&#39;</span><span class="p">;</span>
<span class="n">w100_1b</span><span class="p">=</span><span class="n">cut_sqw</span><span class="w"> </span><span class="p">(</span><span class="n">data_source</span><span class="p">,</span><span class="n">proj_100</span><span class="p">,[</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">],</span><span class="mf">0.05</span><span class="p">,[</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">],[</span><span class="mi">60</span><span class="p">,</span><span class="mi">70</span><span class="p">],</span><span class="n">cut_file</span><span class="p">);</span>
</pre></div>
</div>
<p>Now if we want to read this in again at some later time all we need to do is type:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">w100_1b</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">read_sqw</span><span class="p">(</span><span class="n">cut_file</span><span class="p">);</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">w100_1b</span><span class="p">);</span>
<span class="n">lx</span><span class="w"> </span><span class="s">1</span><span class="w"> </span><span class="s">3</span><span class="p">;</span><span class="w"> </span><span class="n">ly</span><span class="w"> </span><span class="s">0.2</span><span class="w"> </span><span class="s">0.8</span>
</pre></div>
</div>
<p>Alternatively you can store the cut data in the Matlab workspace, simply by typing:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">w100_1b</span><span class="p">=</span><span class="n">cut_sqw</span><span class="w"> </span><span class="p">(</span><span class="n">data_source</span><span class="p">,</span><span class="n">proj_100</span><span class="p">,[</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">],</span><span class="mf">0.05</span><span class="p">,[</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">],[</span><span class="mi">60</span><span class="p">,</span><span class="mi">70</span><span class="p">]);</span>
</pre></div>
</div>
<p>Note, however, that the variable <code class="docutils literal notranslate"><span class="pre">w100_1b</span></code> will only be stored in the Matlab workspace, so it could easily be
overwritten, or lost if you quit Matlab without saving your workspace.</p>
<p>As we stated above, the objects that you created using the <code class="docutils literal notranslate"><span class="pre">cut_sqw</span></code> and <code class="docutils literal notranslate"><span class="pre">cut</span></code> commands are all of the type
<code class="docutils literal notranslate"><span class="pre">sqw</span></code>. These are the generic objects dealt with by Horace and can represent data that is 0 to 4- dimensional. The sqw
objects contain information about the contributing pixels to the cut, which in principle allow things like resolution
corrections to be done when you analyse your data. However, in some instances you may not wish to retain this
information, for example if you are dealing with lots of large 4-dimensional objects and are worried about running out
of memory, or if you do not intend to use the pixel information. If this is the case there are two things you can do,
depending on whether you are cutting data from a file or from an object in memory. If cutting data from a file and you
do not wish to retain pixel information then the syntax is</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">w100_2_nopixels</span><span class="p">=</span><span class="n">cut_sqw</span><span class="w"> </span><span class="p">(</span><span class="n">data_source</span><span class="p">,</span><span class="n">proj_100</span><span class="p">,[</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">],</span><span class="mf">0.05</span><span class="p">,[</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">500</span><span class="p">],</span><span class="s">&#39;-nopix&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>If cutting data from an sqw object in memory then the syntax is</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">w100_1d</span><span class="p">=</span><span class="n">cut</span><span class="p">(</span><span class="n">w100_2</span><span class="p">,</span><span class="mf">0.05</span><span class="p">,[</span><span class="mi">60</span><span class="p">,</span><span class="mi">70</span><span class="p">],</span><span class="s">&#39;-nopix&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">w100_2</span></code> is the 2-dimensional sqw object created earlier.</p>
<p>If you make a cut to create an object that is 2-dimensional, but with no pixel information, then it becomes a new type
of Horace object – in this case a <code class="docutils literal notranslate"><span class="pre">d2d</span></code>. If the cut creates a 1-d object then it is known as a <code class="docutils literal notranslate"><span class="pre">d1d</span></code>, and so on. Most
operations that apply to sqw objects also apply to dnd objects, albeit appropriately modified, e.g. the command <code class="docutils literal notranslate"><span class="pre">plot</span></code>
applies to both kinds of data. The most notable difference applies to simulation and fitting of data.</p>
</section>
<section id="basic-data-manipulation">
<h2>Basic data manipulation<a class="headerlink" href="#basic-data-manipulation" title="Permalink to this heading"></a></h2>
<p>Horace allows you to manipulate your data in many different ways. The number of manipulation functions supplied with the
standard download is quite small, however it is relatively easy to write your own bespoke functions – the syntax can be
worked out by looking at the existing functions.</p>
<p>It is important to realise that there are essentially 3 different kinds of function, each with a slightly different
syntax. The first set of functions, which will be described first below, are ones which take an existing data set and
manipulate it in some way before returning the manipulated dataset. An example of this would be dividing the entire
dataset by the Bose factor.</p>
<p>The second kind of function is a general function which takes a number of input vectors, corresponding to the axes of
the desired output object and performs a mathematical operation on them to give an n-dimensional output. An example of
this would be a function called something like <code class="docutils literal notranslate"><span class="pre">gauss_2d</span></code> which takes two vectors that specify a grid in
(<strong>Q</strong>,E)-space and some parameter, and returns a 2D grid with an intensity modeled by a Gaussian.</p>
<p>The final kind of function is a “proper” model of S(<strong>Q</strong>,E), i.e. one which takes all of the values of <strong>Q</strong> and E for
a particular dataset and calculates a dispersion relation, say, which is then plugged into a simple harmonic oscillator
response function.</p>
<p>With the above caveats in mind, let’s demonstrate two different kinds of data manipulation of the first type discussed
above. In the first we will simulate the background for a 2D slice by looking at the signal at high |<strong>Q</strong>| in a
1D cut and then replicating it into 2D and subtracting from the real data. We’ll then demonstrate correcting the data
for the Bose-Einstein thermal population factor.</p>
<p>First create a new 2D slice and save to file:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">cut_file</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&#39;C:\mprogs\Horace\demo\ w110.sqw&#39;</span><span class="p">;</span>
<span class="n">cut_sqw</span><span class="w"> </span><span class="p">(</span><span class="n">data_source</span><span class="p">,</span><span class="w"> </span><span class="n">proj_110</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mf">0.05</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">150</span><span class="p">],</span><span class="w"> </span><span class="n">cut_file</span><span class="p">);</span>
<span class="n">w110</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">read_sqw</span><span class="p">(</span><span class="n">cut_file</span><span class="p">);</span>
</pre></div>
</div>
<p>Now make a 1D cut out of this slice along the energy axis, with the integration range along (0,1,0) of 4.8 to 5:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">wbackcut</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">cut</span><span class="p">(</span><span class="n">w110</span><span class="p">,</span><span class="mi">1</span><span class="p">,[</span><span class="mf">4.8</span><span class="p">,</span><span class="mi">5</span><span class="p">]);</span>
</pre></div>
</div>
<p>Next make a new 2D slice by replicating the cut along one of the integration axes:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">wback</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">replicate</span><span class="p">(</span><span class="n">wbackcut</span><span class="p">,</span><span class="n">w110</span><span class="p">);</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">wback</span><span class="p">);</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/Screenshot_background_replicated.png"><img alt="2d cut made by replicating a 1d cut" src="../_images/Screenshot_background_replicated.png" style="width: 300px;" /></a>
<p>This is a 2D slice that is over the same range as w110. We now subtract this from the real data:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">wdiff</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">w110</span><span class="o">-</span><span class="n">wback</span><span class="p">;</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">wdiff</span><span class="p">);</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/Screenshot_background_subtracted.png"><img alt="Background-subtracted data" src="../_images/Screenshot_background_subtracted.png" style="width: 300px;" /></a>
</section>
<section id="simulations">
<h2>Simulations<a class="headerlink" href="#simulations" title="Permalink to this heading"></a></h2>
<p>It is not only possible to plot and manipulate data, it is also possible to simulate an entire dataset, or parts of a
dataset. We will illustrate this option using two examples, one that gives a quartet of Gaussian profile peaks, and
another that simulates the intensity from a Heisenberg ferromagnet.</p>
<p>It is often the case that you do not have a full model of S(<strong>Q</strong>,E), but rather you just want to determine how a
particular peak changes with, for example, temperature or neutron energy transfer. An example would be to monitor the
positions and intensities of a quartet peaks. We can generate a slice from our demo data by typing:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">w_template</span><span class="p">=</span><span class="n">cut_sqw</span><span class="p">(</span><span class="n">data_source</span><span class="p">,</span><span class="n">proj_100</span><span class="p">,[</span><span class="o">-</span><span class="mf">0.4</span><span class="p">,</span><span class="mf">0.2</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.05</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.05</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">30</span><span class="p">,</span><span class="mi">40</span><span class="p">]);</span>
</pre></div>
</div>
<p>This should give a plot that looks like this:</p>
<a class="reference internal image-reference" href="../_images/Screenshot_CutToSim.png"><img alt="2d data" src="../_images/Screenshot_CutToSim.png" style="width: 300px;" /></a>
<p>We will now simulate this using the demonstration function <code class="docutils literal notranslate"><span class="pre">demo_4gauss</span></code>. This is a specially written function which
works only for 2D datasets (slices) where both axes are momentum. Read through the code in</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">C</span><span class="p">:</span><span class="o">\</span><span class="n">mprogs</span><span class="o">\</span><span class="n">Horace</span><span class="o">\</span><span class="nb">functions</span><span class="o">\</span><span class="n">demo_4gauss</span><span class="p">.</span><span class="n">m</span>
</pre></div>
</div>
<p>to see if you can understand how the function works… It is a far from simple task to write a function that is
completely general for any dimensionality of dataset, so you typically write functions such as this that work only for a
particular dimensionality. It is important, therefore, for your own book-keeping, that you give the functions sensible
names that reflect both what they do and what sort of dataset they apply to.</p>
<p>Now let’s run the function. Instead of using <code class="docutils literal notranslate"><span class="pre">user_func</span></code> we will use <code class="docutils literal notranslate"><span class="pre">func_eval</span></code>. The syntax for functions called by
this routine is slightly different:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">w_sim</span><span class="p">=</span><span class="w"> </span><span class="n">func_eval</span><span class="w"> </span><span class="p">(</span><span class="n">w_template</span><span class="p">,@</span><span class="n">demo_4gauss</span><span class="p">,[</span><span class="mi">6</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mf">0.1</span><span class="w"> </span><span class="mf">1.25</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">1</span><span class="p">]);</span>
</pre></div>
</div>
<p>The arguments in the square parentheses are the function inputs, and in this case they correspond respectively to
amplitude, satellite position x-coordinate, satellite y-coordinate, central position x-coordinate, central y-coordinate,
and background. In general the input to a function called by <code class="docutils literal notranslate"><span class="pre">func_eval</span></code> can take any form (e.g. a cell array, a
structure array, a string, etc.), although if you wish to pass anything other than a vector of parameters, such as that
shown above, then it must be packed into a cell array.</p>
<p>Notice that the syntax of the input arguments is somewhat different for <code class="docutils literal notranslate"><span class="pre">func_eval</span></code> compared to <code class="docutils literal notranslate"><span class="pre">user_func</span></code>, since
with the former we input the parameters as a vector, rather than as separate arguments. The form of the function itself
is also different, since it takes some arrays of parameters and calculates an intensity at those points, rather than
taking an existing intensity array and modifying it.</p>
<a class="reference internal image-reference" href="../_images/Screenshot_SimCut.png"><img alt="2d simulation" src="../_images/Screenshot_SimCut.png" style="width: 300px;" /></a>
<p><code class="docutils literal notranslate"><span class="pre">func_eval</span></code> works for both sqw and dnd objects with almost the same syntax. For sqw objects pixel information is
simulated according to the intensity calculated for the data grid, whereas for dnd objects this is not required. It is
also possible to simulate a dnd from a template sqw object by using an additional keyword argument of the form</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">dnd_sim</span><span class="p">=</span><span class="w"> </span><span class="n">func_eval</span><span class="w"> </span><span class="p">(</span><span class="n">w_template</span><span class="p">,@</span><span class="n">demo_4gauss</span><span class="p">,[</span><span class="mi">6</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mf">0.1</span><span class="w"> </span><span class="mf">1.25</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">1</span><span class="p">],</span><span class="s">&#39;all&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>Furthermore one can use the same keyword argument on a template dnd object so that intensity is simulated over the
entire data range, rather than just at the points where there are data in the template object.</p>
<p>There is another way of performing a simulation, using a different method and a simulation function with a slightly
different input structure. In this case you are fitting a full model of S(<strong>Q</strong>,E), so the function we will demonstrate
here is a model appropriate for spin excitations of a 3D Heisenberg ferromagnet. The function is called
<code class="docutils literal notranslate"><span class="pre">FM_spinwaves_2dSlice_sqw</span></code>, and it takes as its inputs arrays (or scalars) for all 3 components of <strong>Q</strong> plus energy,
as well as the other function parameters (exchange constant etc.). The format of the inputs for this function are thus
different from those of <code class="docutils literal notranslate"><span class="pre">demo_4gauss</span></code> - to see the differences it is probably easiest to examine the code for the two
functions side-by-side.</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">w_sim</span><span class="p">=</span><span class="w"> </span><span class="n">sqw_eval</span><span class="w"> </span><span class="p">(</span><span class="n">w_template</span><span class="p">,@</span><span class="n">FM_spinwaves_2dSlice_sqw</span><span class="p">,[</span><span class="mi">300</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="mi">2</span><span class="p">]);</span>
</pre></div>
</div>
<p>In general it is better to use <code class="docutils literal notranslate"><span class="pre">func_eval</span></code> for simple functions such as Gaussians and so on, and sqw for “proper”
models of the scattering. The different syntax makes it easier to keep track of what kind of model for the scattering is
being employed. As before, the keyword <code class="docutils literal notranslate"><span class="pre">'all'</span></code> can be added to the arguments of this function, however in this case it is
ignored if the object <code class="docutils literal notranslate"><span class="pre">w_template</span></code> is an sqw object. If <code class="docutils literal notranslate"><span class="pre">w_template</span></code> is a dnd object then as for func_eval the
keyword <code class="docutils literal notranslate"><span class="pre">'all'</span></code> ensures that data are simulated over the entire data range. As with <code class="docutils literal notranslate"><span class="pre">func_eval</span></code>, the parameters passed
to the function can either take the form of a vector of numerical parameters, or a cell array comprising any other form
of input.</p>
</section>
<section id="fitting">
<h2>Fitting<a class="headerlink" href="#fitting" title="Permalink to this heading"></a></h2>
<p>You can also use Horace to fit your data. It can take quite a long time for the fit to converge, so it is therefore a
good idea to provide a good initial guess of the fit parameters. You can work these out simulating and then comparing
the result to the data by eye.</p>
<p>For an introduction and overview of how to use the following fitting functions, please read
<a class="reference internal" href="../manual/Multifit.html#multifit"><span class="std std-ref">Fitting data</span></a>. For comprehensive help, please use the Matlab documentation for the various fitting
functions that can be obtained by using the <code class="docutils literal notranslate"><span class="pre">doc</span></code> command, for example <code class="docutils literal notranslate"><span class="pre">doc</span> <span class="pre">d1d/multifit</span></code> (for fitting function like
Gaussians to d1d objects) or <code class="docutils literal notranslate"><span class="pre">doc</span> <span class="pre">sqw/multifit_sqw</span></code> (fitting models for S(Q,w) to sqw objects).</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../User_guide.html" class="btn btn-neutral float-left" title="User’s Guide" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Horace_GUI.html" class="btn btn-neutral float-right" title="Horace GUI" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2006-2023, STFC RAL.
      <span class="lastupdated">Last updated on Oct 4, 2023, 4:03:51 PM.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
  
<br><br>
<a href="https://github.com/pace-neutrons/Horace/edit/master/documentation/user_docs/docs/user_guide/Getting_started.rst">Click here to edit</a> or <a href="https://github.com/pace-neutrons/Horace/edit/master/documentation/user_docs/docs/new_page.rst">Click here to add new page</a> (requires <a href="https://github.com/login">GitHub account</a>).
<br>
For more info on editing <a href="../Contributing.html">click here</a>.


</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>