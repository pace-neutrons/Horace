<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>API Reference &mdash; Horace  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="General disclaimer" href="General_disclaimer.html" />
    <link rel="prev" title="Developer info" href="developers/Developer_info.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> Horace
            <img src="_static/150px-Quintus_Horatius_Flaccus.jpg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Introduction.html">Introduction and Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="User_guide.html">User’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="Horace_manual.html">Horace Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="Citing.html">Citing Horace</a></li>
<li class="toctree-l1"><a class="reference internal" href="Developers.html">For Developers</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-sqw.&#64;SQWDnDBase"><code class="docutils literal notranslate"><span class="pre">SQWDndBase</span></code> class</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-sqw.&#64;Experiment"><code class="docutils literal notranslate"><span class="pre">Experiment</span></code> class</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-sqw.PixelData.&#64;PixelData"><code class="docutils literal notranslate"><span class="pre">PixelData</span></code> class</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="General_disclaimer.html">General disclaimer</a></li>
<li class="toctree-l1"><a class="reference internal" href="Privacy_policy.html">Privacy Policy</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Horace</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>API Reference</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/API_Reference.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="api-reference">
<h1><a class="toc-backref" href="#id5">API Reference</a><a class="headerlink" href="#api-reference" title="Permalink to this headline"></a></h1>
<div class="contents topic" id="table-of-contents">
<p class="topic-title">Table of Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#api-reference" id="id5">API Reference</a></p>
<ul>
<li><p><a class="reference internal" href="#module-sqw.&#64;SQWDnDBase" id="id6"><code class="docutils literal notranslate"><span class="pre">SQWDndBase</span></code> class</a></p></li>
<li><p><a class="reference internal" href="#module-sqw.&#64;Experiment" id="id7"><code class="docutils literal notranslate"><span class="pre">Experiment</span></code> class</a></p></li>
<li><p><a class="reference internal" href="#module-sqw.PixelData.&#64;PixelData" id="id8"><code class="docutils literal notranslate"><span class="pre">PixelData</span></code> class</a></p></li>
</ul>
</li>
</ul>
</div>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">API Index</span></a></p></li>
</ul>
<section id="module-sqw.&#64;SQWDnDBase">
<span id="sqwdndbase-class"></span><h2><a class="toc-backref" href="#id6"><code class="docutils literal notranslate"><span class="pre">SQWDndBase</span></code> class</a><a class="headerlink" href="#module-sqw.@SQWDnDBase" title="Permalink to this headline"></a></h2>
<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.IX_dataset_1d">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">IX_dataset_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.IX_dataset_1d" title="Permalink to this definition"></a></dt>
<dd><p>Convert 1D sqw object into IX_dataset_1d</p>
<p>&gt;&gt; wout = IX_dataset_1d (w)</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.IX_dataset_2d">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">IX_dataset_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.IX_dataset_2d" title="Permalink to this definition"></a></dt>
<dd><p>Convert 2D sqw object into IX_dataset_2d</p>
<p>&gt;&gt; wout = IX_dataset_2d (w)</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.IX_dataset_3d">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">IX_dataset_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.IX_dataset_3d" title="Permalink to this definition"></a></dt>
<dd><p>Convert 3D sqw object into IX_dataset_3d</p>
<p>&gt;&gt; wout = IX_dataset_3d (w)</p>
</dd></dl>

<dl class="mat class">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.SQWDnDBase">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">SQWDnDBase</span></span><a class="headerlink" href="#sqw.@SQWDnDBase.SQWDnDBase" title="Permalink to this definition"></a></dt>
<dd><p>SQWDnDBase Abstract SQW/DnD object base class
Abstract class defining common API and atrributes of the SQW and
DnD objects</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.acos">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">acos</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.acos" title="Permalink to this definition"></a></dt>
<dd><p>Implements acos(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = acos(w1)</p>
</div></blockquote>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.acosh">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">acosh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.acosh" title="Permalink to this definition"></a></dt>
<dd><p>Implements acosh(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = acosh(w1)</p>
</div></blockquote>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.acot">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">acot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.acot" title="Permalink to this definition"></a></dt>
<dd><p>Implements acot(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = acot(w1)</p>
</div></blockquote>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.acoth">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">acoth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.acoth" title="Permalink to this definition"></a></dt>
<dd><p>Implements acoth(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = acoth(w1)</p>
</div></blockquote>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.acsc">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">acsc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.acsc" title="Permalink to this definition"></a></dt>
<dd><p>Implements acsc(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = acsc(w1)</p>
</div></blockquote>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.acsch">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">acsch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.acsch" title="Permalink to this definition"></a></dt>
<dd><p>Implements acsch(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = acsch(w1)</p>
</div></blockquote>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.asec">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">asec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.asec" title="Permalink to this definition"></a></dt>
<dd><p>Implements asec(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = asec(w1)</p>
</div></blockquote>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.asech">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">asech</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.asech" title="Permalink to this definition"></a></dt>
<dd><p>Implements asech(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = asech(w1)</p>
</div></blockquote>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.asin">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">asin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.asin" title="Permalink to this definition"></a></dt>
<dd><p>Implements asin(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = asin(w1)</p>
</div></blockquote>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.asinh">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">asinh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.asinh" title="Permalink to this definition"></a></dt>
<dd><p>Implements asinh(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = asinh(w1)</p>
</div></blockquote>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.atan">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">atan</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.atan" title="Permalink to this definition"></a></dt>
<dd><p>Implements atan(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = atan(w1)</p>
</div></blockquote>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.atanh">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">atanh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.atanh" title="Permalink to this definition"></a></dt>
<dd><p>Implements atanh(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = atanh(w1)</p>
</div></blockquote>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.binary_op_manager">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">binary_op_manager</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em>, <em class="sig-param"><span class="pre">w2</span></em>, <em class="sig-param"><span class="pre">binary_op</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.binary_op_manager" title="Permalink to this definition"></a></dt>
<dd><p>Implements a binary operation for objects with a signal and a variance array.</p>
<blockquote>
<div><p>&gt;&gt; w = binary_op_manager(w1, w2, binary_op)</p>
</div></blockquote>
<p>All binary operations on Matlab double arrays are permitted
(+, -, <a href="#id1"><span class="problematic" id="id2">*</span></a>, /, ) and are applied element by element to the signal and
variance arrays.</p>
<blockquote>
<div><dl>
<dt>w1, w2      Objects on which the binary operation is to be performed.</dt><dd><p>One of these can be a Matlab double (i.e. double precision)
array, in which case the variance array is taken to be zero.</p>
<p>If w1, w2 are scalar objects with the same signal array sizes:
- The operation is performed element-by-element.</p>
<p>If one of w1 or w2 is a double array (and the other is a
scalar object):
- If a scalar, apply to each element of the object signal.
- If it is an array of the same size as the object signal</p>
<blockquote>
<div><p>array, apply the operation element by element.</p>
</div></blockquote>
<p>If one or both of w1 and w2 are arrays of objects:
- If objects have same array sizes, the binary operation is</p>
<blockquote>
<div><p>applied object element-by-object element.</p>
</div></blockquote>
<ul class="simple">
<li><p>If one of the objects is scalar (i.e. only one object),</p></li>
</ul>
<blockquote>
<div><p>then it is applied by the binary operation to each object
in the other array.</p>
</div></blockquote>
<p>If one of w1, w2 is an array of objects and the other is a
double array:
- If the double is a scalar, it is applied to every object</p>
<blockquote>
<div><p>in the array.</p>
</div></blockquote>
<ul class="simple">
<li><p>If the double is an array with the same size as the object</p></li>
</ul>
<blockquote>
<div><p>array, then each element is applied as a scalar to the
corresponding object in the object array.</p>
</div></blockquote>
<ul class="simple">
<li><p>If the double is an array with larger size than the object</p></li>
</ul>
<blockquote>
<div><p>array, then the array is resolved into a stack of arrays,
where the stack has the same size as the object array, and
the each array in the stack is applied to the corresponding
object in the object array. [Note that for this operation
to be valid, each object must have the same signal array
size.]</p>
</div></blockquote>
</dd>
<dt>binary_op   Function handle to a binary operation. All binary operations</dt><dd><p>on Matlab double or single arrays are permitted (+, -, <a href="#id3"><span class="problematic" id="id4">*</span></a>,
/, ).</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
<p>NOTES:
This is a generic method - works for any class (including sigvar)
so long as the methods below are defined on that class.</p>
<p>Requires that objects have the following methods to find the size of the
public signal and variance arrays, create a sigvar object from those
arrays, and set them from another sigvar object.</p>
<blockquote>
<div><dl class="simple">
<dt>&gt;&gt; sz = sigvar_size(obj)    % Returns size of public signal and variance</dt><dd><p>% arrays</p>
</dd>
<dt>&gt;&gt; w = sigvar(obj)          % Create a sigvar object from the public</dt><dd><p>% signal and variance arrays</p>
</dd>
<dt>&gt;&gt; obj = sigvar_set(obj,w)  % Set signal and variance in an object from</dt><dd><p>% those in a sigvar object</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.calculate_q_bins">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">calculate_q_bins</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">win</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.calculate_q_bins" title="Permalink to this definition"></a></dt>
<dd><p>Calculate qh,qk,ql,en for the centres of the bins of an n-dimensional sqw or dnd dataset</p>
<blockquote>
<div><p>&gt;&gt; [q,en]=calculate_q_bins(win)</p>
</div></blockquote>
<blockquote>
<div><p>win     Input sqw/dnd object</p>
</div></blockquote>
<blockquote>
<div><dl>
<dt>q       Components of momentum (in rlu) for each bin in the dataset for a single energy bin</dt><dd><p>Arrays are packaged as cell array of column vectors for convenience
with fitting routines etc.</p>
<blockquote>
<div><p>i.e. q{1}=qh, q{2}=qk, q{3}=ql</p>
</div></blockquote>
</dd>
<dt>en      Column vector of energy bin centres. If energy was an integration axis, then returns the</dt><dd><p>centre of the energy integration range</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.calculate_qw_bins">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">calculate_qw_bins</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">win</span></em>, <em class="sig-param"><span class="pre">optstr</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.calculate_qw_bins" title="Permalink to this definition"></a></dt>
<dd><p>Calculate qh,qk,ql,en for the centres of the bins of an n-dimensional sqw or dnd dataset</p>
<blockquote>
<div><p>&gt;&gt; qw=calculate_qw_bins(win)
&gt;&gt; qw=calculate_qw_bins(win,’boundaries’)
&gt;&gt; qw=calculate_qw_bins(win,’edges’)</p>
</div></blockquote>
<blockquote>
<div><p>win         Input sqw or dnd object</p>
</div></blockquote>
<p>Optional arguments:
‘boundaries’  Return qh,qk,ql,en at verticies of bins, not centres
‘edges’       Return qh,qk,ql,en at verticies of the hyper cuboid that</p>
<blockquote>
<div><p>encloses the plot axes</p>
</div></blockquote>
<blockquote>
<div><dl>
<dt>qw          Components of momentum (in rlu) and energy for each bin in</dt><dd><p>the dataset Arrays are packaged as cell array of column vectors
for convenience with fitting routines etc.</p>
<blockquote>
<div><blockquote>
<div><p>i.e. qw{1}=qh, qw{2}=qk, qw{3}=ql, qw{4}=en</p>
</div></blockquote>
<p>Note that the centre of the integration range is used in</p>
</div></blockquote>
<p>the calculation of qh,qk,ql,en even with the options
‘boundaries’ or ‘edges’</p>
<blockquote>
<div><p>If one or both of the integration ranges is infinite, then</p>
</div></blockquote>
<p>the value of the corresponding coordinate is taken as zero.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.change_crystal">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">change_crystal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.change_crystal" title="Permalink to this definition"></a></dt>
<dd><p>Change the crystal lattice and orientation of an sqw object or array of objects</p>
<dl class="simple">
<dt>Most commonly:</dt><dd><p>&gt;&gt; wout = change_crystal (w, rlu_corr)              % change lattice parameters and orientation</p>
</dd>
<dt>OR</dt><dd><p>&gt;&gt; wout = change_crystal (w, alatt)                 % change just length of lattice vectors
&gt;&gt; wout = change_crystal (w, alatt, angdeg)         % change all lattice parameters
&gt;&gt; wout = change_crystal (w, alatt, angdeg, rotmat) % change lattice parameters and orientation
&gt;&gt; wout = change_crystal (w, alatt, angdeg, u, v)   % change lattice parameters and redefine u, v</p>
</dd>
</dl>
<blockquote>
<div><p>w           Input sqw object</p>
<dl>
<dt>rlu_corr    Matrix to convert notional rlu in the current crystal lattice to</dt><dd><p>the rlu in the the new crystal lattice together with any re-orientation
of the crystal. The matrix is defined by the matrix:</p>
<blockquote>
<div><blockquote>
<div><p>qhkl(i) = rlu_corr(i,j) * qhkl_0(j)</p>
</div></blockquote>
<p>This matrix can be obtained from refining the lattice and</p>
</div></blockquote>
<p>orientation with the function refine_crystal (type
&gt;&gt; help refine_crystal  for more details).</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt><em>OR</em></dt><dd><p>alatt       New lattice parameters [a,b,c] (Angstroms)
angdeg      New lattice angles [alf,bet,gam] (degrees)
rotmat      Rotation matrix that relates crystal Cartesian coordinate frame of the new</p>
<blockquote>
<div><p>lattice as a rotation of the current crystal frame. Orthonormal coordinates
in the two frames are related by</p>
<blockquote>
<div><p>v_new(i)= rotmat(i,j)*v_current(j)</p>
</div></blockquote>
</div></blockquote>
<dl class="simple">
<dt>u, v        Redefine the two vectors that were used to determine the scattering plane</dt><dd><p>These are the vectors at whatever disorientation angles dpsi, gl, gs (which
cannot be changed).</p>
</dd>
</dl>
</dd>
</dl>
<blockquote>
<div><p>wout        Output sqw object with changed crystal lattice parameters and orientation</p>
</div></blockquote>
<dl>
<dt>NOTE</dt><dd><p>The input data set(s) can be reset to their original orientation by inverting the
input data e.g.</p>
<blockquote>
<div><ul class="simple">
<li><p>call with inv(rlu_corr)</p></li>
<li><p>call with the original alatt, angdeg, u and v</p></li>
</ul>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.compact">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">compact</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">win</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.compact" title="Permalink to this definition"></a></dt>
<dd><p>Squeezes the data range in an sqw or dnd object to eliminate empty bins</p>
<dl class="simple">
<dt>Syntax:</dt><dd><p>&gt;&gt; wout = compact(win)</p>
</dd>
</dl>
<blockquote>
<div><p>win         Input object</p>
</div></blockquote>
<blockquote>
<div><dl class="simple">
<dt>wout        Output object, with length of axes reduced to yield the</dt><dd><p>smallest cuboid that contains the non-empty bins.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.convert_bins_for_shoelace">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">convert_bins_for_shoelace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">win</span></em>, <em class="sig-param"><span class="pre">wref</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.convert_bins_for_shoelace" title="Permalink to this definition"></a></dt>
<dd><p>Converts data in the d2d object win into appropriate format for the
shoelace rebinning function (i.e. bin corners rather than bin
boundaries). The co-ordinate system is defined by the d2d object wref. If
wref is empty then the co-ordinate system remains unchanged.</p>
<p>RAE 23/9/09</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.cos">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">cos</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.cos" title="Permalink to this definition"></a></dt>
<dd><p>Implements cos(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = cos(w1)</p>
</div></blockquote>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.cosh">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">cosh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.cosh" title="Permalink to this definition"></a></dt>
<dd><p>Implements cosh(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = cosh(w1)</p>
</div></blockquote>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.cot">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">cot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.cot" title="Permalink to this definition"></a></dt>
<dd><p>Implements cot(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = cot(w1)</p>
</div></blockquote>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.coth">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">coth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.coth" title="Permalink to this definition"></a></dt>
<dd><p>Implements coth(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = coth(w1)</p>
</div></blockquote>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.csc">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">csc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.csc" title="Permalink to this definition"></a></dt>
<dd><p>Implements csc(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = csc(w1)</p>
</div></blockquote>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.csch">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">csch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.csch" title="Permalink to this definition"></a></dt>
<dd><p>Implements csch(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = csch(w1)</p>
</div></blockquote>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.da">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">da</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.da" title="Permalink to this definition"></a></dt>
<dd><p>Draw an area plot of a 2D sqw dataset or array of datasets</p>
<blockquote>
<div><p>&gt;&gt; da(w)
&gt;&gt; da(w,xlo,xhi)
&gt;&gt; da(w,xlo,xhi,ylo,yhi)
&gt;&gt; da(w,xlo,xhi,ylo,yhi,zlo,zhi)</p>
</div></blockquote>
<dl>
<dt>Advanced use:</dt><dd><p>&gt;&gt; da(w,…,’name’,fig_name)        % Draw with name = fig_name</p>
<dl class="simple">
<dt>&gt;&gt; da(w,…,’-noaspect’)            % Do not change aspect ratio</dt><dd><p>% according to data axes unit lengths</p>
</dd>
</dl>
</dd>
<dt>Return figure, axes and plot handles:</dt><dd><p>&gt;&gt; [fig_handle, axes_handle, plot_handle] = da(w,…)</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.dd">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">dd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.dd" title="Permalink to this definition"></a></dt>
<dd><p>Draws a plot of markers, error bars and lines of a 1D sqw object or array of objects</p>
<blockquote>
<div><p>&gt;&gt; dd(w)
&gt;&gt; dd(w,xlo,xhi)
&gt;&gt; dd(w,xlo,xhi,ylo,yhi)</p>
</div></blockquote>
<dl class="simple">
<dt>Advanced use:</dt><dd><p>&gt;&gt; dd(w,…,’name’,fig_name)        % draw with name = fig_name</p>
</dd>
<dt>Return figure, axes and plot handles:</dt><dd><p>&gt;&gt; [fig_handle, axes_handle, plot_handle] = dd(w,…)</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.de">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">de</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.de" title="Permalink to this definition"></a></dt>
<dd><p>Draws a plot of error bars of a 1D sqw object or array of objects</p>
<blockquote>
<div><p>&gt;&gt; de(w)
&gt;&gt; de(w,xlo,xhi)
&gt;&gt; de(w,xlo,xhi,ylo,yhi)</p>
</div></blockquote>
<dl class="simple">
<dt>Advanced use:</dt><dd><p>&gt;&gt; de(w,…,’name’,fig_name)        % draw with name = fig_name</p>
</dd>
<dt>Return figure, axes and plot handles:</dt><dd><p>&gt;&gt; [fig_handle, axes_handle, plot_handle] = de(w,…)</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.dh">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">dh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.dh" title="Permalink to this definition"></a></dt>
<dd><p>Draws a histogram plot of a 1D sqw object or array of objects</p>
<blockquote>
<div><p>&gt;&gt; dh(w)
&gt;&gt; dh(w,xlo,xhi)
&gt;&gt; dh(w,xlo,xhi,ylo,yhi)</p>
</div></blockquote>
<dl class="simple">
<dt>Advanced use:</dt><dd><p>&gt;&gt; dh(w,…,’name’,fig_name)        % draw with name = fig_name</p>
</dd>
<dt>Return figure, axes and plot handles:</dt><dd><p>&gt;&gt; [fig_handle, axes_handle, plot_handle] = dh(w,…)</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.dimensions">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">dimensions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.dimensions" title="Permalink to this definition"></a></dt>
<dd><p>Find number of dimensions and extent along each dimension of
the signal arrays.
- If 0D sqw object, nd=0,  sz=zeros(1,0) (nb: []==zeros(0,0))
- if 1D sqw object, nd=1,  sz=n1
- If 2D sqw object, nd=2,  sz=[n1,n2]
- If 3D sqw object, nd=3,  sz=[n1,n2,n3]   even if n3=1
- If 4D sqw object, nd=4,  sz=[n1,n2,n3,n4]  even if n4=1</p>
<p>The convention is that size(sz)=1 x ndim</p>
<blockquote>
<div><p>&gt;&gt; [nd,sz]=dimensions(w)</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.dimensions_match">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">dimensions_match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em>, <em class="sig-param"><span class="pre">nd_ref</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.dimensions_match" title="Permalink to this definition"></a></dt>
<dd><p>Check that the dimensions of an array of sqw objects are all the same</p>
<blockquote>
<div><p>&gt;&gt; [ok,mess]=dimensions_match(w)
&gt;&gt; [ok,mess]=dimensions_match(w,nref)</p>
</div></blockquote>
<blockquote>
<div><p>w       sqw object or array of objects
nd_ref  [optional] If not given, check all sqw objects in the array</p>
<blockquote>
<div><p>have the same dimensionality. If given, check that they match
this dimensionality</p>
</div></blockquote>
</div></blockquote>
<blockquote>
<div><p>ok      True if all have the smae dimensionality (and match nref, if given)
mess    Empty if ok==true; error message if not
nd      Dimensionality</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.disp2sqw_eval">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">disp2sqw_eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">win</span></em>, <em class="sig-param"><span class="pre">dispreln</span></em>, <em class="sig-param"><span class="pre">pars</span></em>, <em class="sig-param"><span class="pre">fwhh</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.disp2sqw_eval" title="Permalink to this definition"></a></dt>
<dd><p>Calculate sqw for a model scattering function</p>
<blockquote>
<div><p>&gt;&gt; wout = disp2sqw_eval(win,dispreln,pars,fwhh,varargin)</p>
</div></blockquote>
<blockquote>
<div><dl>
<dt>win         Dataset, or array of datasets, that provides the axes and points</dt><dd><p>for the calculation</p>
</dd>
<dt>dispreln    Handle to function that calculates the dispersion relation w(Q) and</dt><dd><p>spectral weight, s(Q)
Must have form:</p>
<blockquote>
<div><blockquote>
<div><p>[w,s] = dispreln (qh,qk,ql,p)</p>
</div></blockquote>
<dl class="simple">
<dt>where</dt><dd><dl class="simple">
<dt>qh,qk,ql    Arrays containing the coordinates of a set of points</dt><dd><p>in reciprocal lattice units</p>
</dd>
<dt>p           Vector of parameters needed by dispersion function</dt><dd><p>e.g. [A,js,gam] as intensity, exchange, lifetime</p>
</dd>
<dt>w           Array of corresponding energies, or, if more than</dt><dd><p>one dispersion relation, a cell array of arrays.</p>
</dd>
<dt>s           Array of spectral weights, or, if more than</dt><dd><p>one dispersion relation, a cell array of arrays.</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>More general form is:</dt><dd><blockquote>
<div><p>[w,s] = dispreln (qh,qk,ql,p,c1,c2,..)</p>
</div></blockquote>
<dl class="simple">
<dt>where</dt><dd><dl class="simple">
<dt>p           Typically a vector of parameters that we might want</dt><dd><p>to fit in a least-squares algorithm</p>
</dd>
<dt>c1,c2,…   Other constant parameters e.g. file name for look-up</dt><dd><p>table.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>pars        Arguments needed by the function. Most commonly, a vector of parameter</dt><dd><p>values e.g. [A,js,gam] as intensity, exchange, lifetime. If a more general
set of parameters is required by the function, then
package these into a cell array and pass that as pars. In the example
above then pars = {p, c1, c2, …}</p>
</dd>
<dt>fwhh       Parametrizes the resolution function. There are three</dt><dd><blockquote>
<div><p>possible input values of fwhh:</p>
</div></blockquote>
<dl>
<dt>double              A single FWHM value determines the FWHM of the</dt><dd><p>Gaussian resolution function</p>
</dd>
<dt>function_handle     A function that produces the FWHM value as a</dt><dd><p>function of energy transfer, it has to have the
following simple header (where omega can be a row
vector of energies:</p>
<blockquote>
<div><p>dE = resfun(omega)</p>
</div></blockquote>
</dd>
<dt>function_handle     A function handle of a function with two input</dt><dd><dl class="simple">
<dt>parameters with the following header:</dt><dd><p>I = shapefun(Emat,omega)</p>
</dd>
</dl>
<p>where Emat is a matrix with dimensions of [nQ nE]
and omega is a column vector with nQ elements. The
shapefun produces a peakshape for every Q point
centered at the given omega and normalized to one.
The output I has the same dimensions as the
input Emat.</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>Optional arguments: (varargin)</p>
<blockquote>
<div><dl>
<dt>‘-al[l]’  Requests that the calculated sqw be returned over</dt><dd><p>the whole of the domain of the input dataset. If not given, then
the function will be returned only at those points of the dataset
that contain data.
Applies only to input with no pixel information - it is ignored if
full sqw object.</p>
</dd>
<dt>‘-av[erage]’ Requests that the calculated sqw be computed for the</dt><dd><p>average values of h,k,l of the pixels in a bin, not for each
pixel individually. Reduces cost of expensive calculations.</p>
<blockquote>
<div><p>Applies only to the case of sqw object with pixel information - it is</p>
</div></blockquote>
<p>ignored if dnd type object.</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>wout        Output dataset or array of datasets</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.dispersion">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">dispersion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">win</span></em>, <em class="sig-param"><span class="pre">dispreln</span></em>, <em class="sig-param"><span class="pre">pars</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.dispersion" title="Permalink to this definition"></a></dt>
<dd><p>Calculate dispersion relation for dataset or array of datasets.</p>
<blockquote>
<div><p>&gt;&gt; wdisp = dispersion (win, dispreln, p)            % dispersion only
&gt;&gt; [wdisp,weight] = dispersion (win, dispreln, p)   % dispersion and spectral weight</p>
</div></blockquote>
<p>The output dataset (or array of data sets), wdisp, will retain only the Q axes, and
the signal array(s) will contain the values of energy along the Q axes. If the
dispersion relation returns the spectral weight, this will be placed in the error
array (actually the square of the spectral weight is put in the error array). In the
case when the dispersion has been calculated on a plane in momentum (i.e. wdisp
is IX_datset_2d) then the plot function ps2 (for plot_surface2)</p>
<blockquote>
<div><p>&gt;&gt; ps2(wdisp)</p>
</div></blockquote>
<p>will plot a surface with the z axis as energy and coloured according to the spectral
weight.</p>
<p>The dispersion relation is calculated at the bin centres (that is, the individual pixel
information in a sqw input object is not used).</p>
<p>If the function that calculates dispersion relations produces more than one
branch, then in the case of a single input dataset the output will be an array
of datasets, one for each branch. If the input is an array of datasets, then only
the first dispersion branch will be returned, so there is one output dataset per
input dataset.</p>
<blockquote>
<div><dl>
<dt>win         Dataset that provides the axes and points for the calculation</dt><dd><blockquote>
<div><p>If one of the plot axes is energy transfer, then the output dataset</p>
</div></blockquote>
<p>will have dimensionality one less than the input dataset</p>
</dd>
<dt>dispreln    Handle to function that calculates the dispersion relation w(Q)</dt><dd><dl>
<dt>Must have form:</dt><dd><blockquote>
<div><p>[w,s] = dispreln (qh,qk,ql,p)</p>
</div></blockquote>
<dl class="simple">
<dt>where</dt><dd><dl class="simple">
<dt>qh,qk,ql    Arrays containing the coordinates of a set of points</dt><dd><p>in reciprocal lattice units</p>
</dd>
<dt>p           Vector of parameters needed by dispersion function</dt><dd><p>e.g. [A,js,gam] as intensity, exchange, lifetime</p>
</dd>
<dt>w           Array of corresponding energies, or, if more than</dt><dd><p>one dispersion relation, a cell array of arrays.</p>
</dd>
<dt>s           Array of spectral weights, or, if more than</dt><dd><p>one dispersion relation, a cell array of arrays.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>More general form is:</dt><dd><blockquote>
<div><p>[w,s] = dispreln (qh,qk,ql,p,c1,c2,..)</p>
</div></blockquote>
<dl class="simple">
<dt>where</dt><dd><dl class="simple">
<dt>p           Typically a vector of parameters that we might want</dt><dd><p>to fit in a least-squares algorithm</p>
</dd>
<dt>c1,c2,…   Other constant parameters e.g. file name for look-up</dt><dd><p>table.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>p           Arguments needed by the function. Most commonly, a vector of parameter</dt><dd><p>values e.g. [A,js,gam] as intensity, exchange, lifetime. If a more general
set of parameters is required by the function, then
package these into a cell array and pass that as pars. In the example
above then pars = {p, c1, c2, …}</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><dl>
<dt>wdisp       Output dataset or array of datasets of the same type as the input argument.</dt><dd><blockquote>
<div><p>The output dataset (or array of data sets) will retain only the Q axes, the</p>
</div></blockquote>
<p>the signal array(s) will contain the values of energy along the Q axes, and
the error array will contain the square of the spectral weight.</p>
<blockquote>
<div><p>If the function that calculates dispersion relations produces more than one</p>
</div></blockquote>
<p>branch, then in the case of a single input dataset the output will be an array
of datasets, one for each branch. If the input is an array of datasets, then only
the first dispersion branch will be returned, so there is one output dataset per
input dataset.</p>
</dd>
<dt>weight      Mirror output: the signal is the spectral weight, and the error array</dt><dd><p>contains the square of the frequency.</p>
</dd>
<dt>e.g.        If win is a 2D dataset with Q and E axes, then wdisp is a 1D dataset</dt><dd><p>with just the Q axis</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.dl">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">dl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.dl" title="Permalink to this definition"></a></dt>
<dd><p>Draws a line plot of a 1D sqw object or array of objects</p>
<blockquote>
<div><p>&gt;&gt; dl(w)
&gt;&gt; dl(w,xlo,xhi)
&gt;&gt; dl(w,xlo,xhi,ylo,yhi)</p>
</div></blockquote>
<dl class="simple">
<dt>Advanced use:</dt><dd><p>&gt;&gt; dl(w,…,’name’,fig_name)        % draw with name = fig_name</p>
</dd>
<dt>Return figure, axes and plot handles:</dt><dd><p>&gt;&gt; [fig_handle, axes_handle, plot_handle] = dl(w,…)</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.dm">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">dm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.dm" title="Permalink to this definition"></a></dt>
<dd><p>Draws a marker plot of a 1D sqw object or array of objects</p>
<blockquote>
<div><p>&gt;&gt; dm(w)
&gt;&gt; dm(w,xlo,xhi)
&gt;&gt; dm(w,xlo,xhi,ylo,yhi)</p>
</div></blockquote>
<dl class="simple">
<dt>Advanced use:</dt><dd><p>&gt;&gt; dm(w,…,’name’,fig_name)        % draw with name = fig_name</p>
</dd>
<dt>Return figure, axes and plot handles:</dt><dd><p>&gt;&gt; [fig_handle, axes_handle, plot_handle] = dm(w,…)</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.dp">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">dp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.dp" title="Permalink to this definition"></a></dt>
<dd><p>Draws a plot of markers and error bars for a 1D sqw object or array of objects</p>
<blockquote>
<div><p>&gt;&gt; dp(w)
&gt;&gt; dp(w,xlo,xhi)
&gt;&gt; dp(w,xlo,xhi,ylo,yhi)</p>
</div></blockquote>
<dl class="simple">
<dt>Advanced use:</dt><dd><p>&gt;&gt; dp(w,…,’name’,fig_name)        % draw with name = fig_name</p>
</dd>
<dt>Return figure, axes and plot handles:</dt><dd><p>&gt;&gt; [fig_handle, axes_handle, plot_handle] = dp(w,…)</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.ds">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">ds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.ds" title="Permalink to this definition"></a></dt>
<dd><p>Draw a surface plot of a 2D sqw dataset or array of datasets</p>
<blockquote>
<div><p>&gt;&gt; ds(w)
&gt;&gt; ds(w,xlo,xhi)
&gt;&gt; ds(w,xlo,xhi,ylo,yhi)
&gt;&gt; ds(w,xlo,xhi,ylo,yhi,zlo,zhi)</p>
</div></blockquote>
<dl>
<dt>Advanced use:</dt><dd><p>&gt;&gt; ds(w,…,’name’,fig_name)        % Draw with name = fig_name</p>
<dl class="simple">
<dt>&gt;&gt; ds(w,…,’-noaspect’)            % Do not change aspect ratio</dt><dd><p>% according to data axes unit lengths</p>
</dd>
</dl>
</dd>
<dt>Return figure, axes and plot handles:</dt><dd><p>&gt;&gt; [fig_handle, axes_handle, plot_handle] = ds(w,…)</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.ds2">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">ds2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.ds2" title="Permalink to this definition"></a></dt>
<dd><p>Draw a surface plot of a 2D sqw dataset or array of datasets</p>
<blockquote>
<div><p>&gt;&gt; ds2(w)       % Use error bars to set colour scale
&gt;&gt; ds2(w,wc)    % Signal in wc sets colour scale</p>
<blockquote>
<div><p>%   wc can be any object with a signal array with same
%  size as w, e.g. sqw object, IX_dataset_2d object, or
%  a numeric array.
%   - If w is an array of objects, then wc must contain
%     the same number of objects.
%   - If wc is a numeric array then w must be a scalar
%     object.</p>
</div></blockquote>
<p>&gt;&gt; ds2(…,xlo,xhi)
&gt;&gt; ds2(…,xlo,xhi,ylo,yhi)
&gt;&gt; ds2(…,xlo,xhi,ylo,yhi,zlo,zhi)</p>
</div></blockquote>
<p>Differs from ds in that the signal sets the z axis, and the colouring is
set by the error bars, or by another object. This enables two related
functions to be plotted (e.g. dispersion relation where the ‘signal’
array holds the energy and the error array holds the spectral weight).</p>
<dl>
<dt>Advanced use:</dt><dd><p>&gt;&gt; ds2(w,…,’name’,fig_name)       % Draw with name = fig_name</p>
<dl class="simple">
<dt>&gt;&gt; ds2(w,…,’-noaspect’)           % Do not change aspect ratio</dt><dd><p>% according to data axes unit lengths</p>
</dd>
</dl>
</dd>
<dt>Return figure, axes and plot handles:</dt><dd><p>&gt;&gt; [fig_handle, axes_handle, plot_handle] = ds2(…)</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.equal_to_tol">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">equal_to_tol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em>, <em class="sig-param"><span class="pre">w2</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.equal_to_tol" title="Permalink to this definition"></a></dt>
<dd><p>Check if two sqw objects are equal to a given tolerance</p>
<blockquote>
<div><p>&gt;&gt; ok = equal_to_tol (a, b)
&gt;&gt; ok = equal_to_tol (a, b, tol)
&gt;&gt; ok = equal_to_tol (…, keyword1, val1, keyword2, val2,…)
&gt;&gt; [ok, mess] = equal_to_tol (…)</p>
</div></blockquote>
<dl class="simple">
<dt>Class specific version of the generic equal_to_tol that by default</dt><dd><ol class="arabic simple">
<li><p>assumes NaN are equivalent (see option ‘nan_equal’), and</p></li>
<li><p>ignores the order of pixels within a bin as the order is irrelevant
(change the default with option ‘reorder’)</p></li>
</ol>
</dd>
</dl>
<p>In addition, it is possible to check the contents of just a random
fraction of non-empty bins (see option ‘fraction’) in order to speed up
the comparison of large objects.</p>
<blockquote>
<div><p>w1,w2   Test objects (scalar objects, or arrays of objects with same sizes)</p>
<dl>
<dt>tol     Tolerance criterion for numeric arrays (Default: [0,0] i.e. equality)</dt><dd><dl class="simple">
<dt>It has the form: [abs_tol, rel_tol] where</dt><dd><p>abs_tol     absolute tolerance (&gt;=0; if =0 equality required)
rel_tol     relative tolerance (&gt;=0; if =0 equality required)</p>
</dd>
</dl>
<p>If either criterion is satified then equality within tolerance
is accepted.</p>
<blockquote>
<div><dl class="simple">
<dt>Examples:</dt><dd><p>[1e-4, 1e-6]    absolute 1e-4 or relative 1e-6 required
[1e-4, 0]       absolute 1e-4 required
[0, 1e-6]       relative 1e-6 required
[0, 0]          equality required
0               equivalent to [0,0]</p>
</dd>
</dl>
</div></blockquote>
<p>For backwards compatibility, a scalar tolerance can be given
where the sign determines absolute or relative tolerance</p>
<blockquote>
<div><blockquote>
<div><p>+ve : absolute tolerance  abserr = abs(a-b)
-ve : relative tolerance  relerr = abs(a-b)/max(abs(a),abs(b))</p>
</div></blockquote>
<dl class="simple">
<dt>Examples:</dt><dd><p>1e-4            absolute tolerance, equivalent to [1e-4, 0]
-1e-6           relative tolerance, equivalent to [0, 1e-6]</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>[To apply an absolute as well as a relative tolerance with a</dt><dd><p>scalar negative value, set the value of the legacy keyword</p>
</dd>
</dl>
<p>‘min_denominator’ (see below)]</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>Valid keywords are:</dt><dd><p>‘nan_equal’      Treat NaNs as equal (true or false; default=true)</p>
<dl>
<dt>‘ignore_str’     Ignore the length and content of strings or cell arrays</dt><dd><p>of strings (true or false; default=false)</p>
</dd>
<dt>‘reorder’        Ignore the order of pixels within each bin</dt><dd><dl class="simple">
<dt>(true or false; default=true)</dt><dd><p>Only applies if sqw-type object</p>
</dd>
</dl>
</dd>
<dt>‘fraction’       Compare pixels in only a fraction of the non-empty bins</dt><dd><blockquote>
<div><blockquote>
<div><dl class="simple">
<dt>(0&lt;= fracton &lt;= 1; default=1 i.e. test all bins)</dt><dd><p>Only applies if sqw-type object</p>
</dd>
</dl>
</div></blockquote>
<p>The reorder and fraction options are available because the order of the</p>
</div></blockquote>
<p>pixels within the pix array for a given bin is unimportant. Reordering
takes time, however, so the option to test on a few bins is given.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.exp">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.exp" title="Permalink to this definition"></a></dt>
<dd><p>Implements exp(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = exp(w1)</p>
</div></blockquote>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.func_eval">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">func_eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">win</span></em>, <em class="sig-param"><span class="pre">func_handle</span></em>, <em class="sig-param"><span class="pre">pars</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.func_eval" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate a function at the plotting bin centres of sqw object or array of sqw object
Syntax:</p>
<blockquote>
<div><p>&gt;&gt; wout = func_eval (win, func_handle, pars)
&gt;&gt; wout = func_eval (win, func_handle, pars, [‘all’])
&gt;&gt; wout = func_eval (win, func_handle, pars, ‘outfile’, ‘output.sqw’)</p>
</div></blockquote>
<p>If function is called on sqw-type object (i.e. has pixels), the pixels’
signal is also modified and evaluated</p>
<blockquote>
<div><dl>
<dt>win         Dataset or array of datasets; the function will be evaluated</dt><dd><p>at the bin centres along the plot axes</p>
</dd>
<dt>func_handle Handle to the function to be evaluated at the bin centres</dt><dd><dl class="simple">
<dt>Must have form:</dt><dd><p>y = my_function (x1,x2,… ,xn,pars)</p>
</dd>
<dt>or, more generally:</dt><dd><p>y = my_function (x1,x2,… ,xn,pars,c1,c2,…)</p>
</dd>
</dl>
<ul class="simple">
<li><p>x1,x2,.xn Arrays of x coordinates along each of the n dimensions</p></li>
<li><p>pars      Parameters needed by the function</p></li>
<li><dl class="simple">
<dt>c1,c2,… Any further arguments needed by the function e.g.</dt><dd><p>they could be the filenames of lookup tables for
resolution effects)</p>
</dd>
</dl>
</li>
</ul>
<dl class="simple">
<dt>e.g. y=gauss2d(x1,x2,[ht,x0,sig])</dt><dd><p>y=gauss4d(x1,x2,x3,x4,[ht,x1_0,x2_0,x3_0,x4_0,sig1,sig2,sig3,sig4])</p>
</dd>
</dl>
</dd>
<dt>pars        Arguments needed by the function.</dt><dd><ul class="simple">
<li><p>Most commonly just a numeric array of parameters</p></li>
<li><p>If a more general set of parameters is needed by the function, then
wrap as a cell array {pars, c1, c2, …}</p></li>
</ul>
</dd>
</dl>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>file</strong> (<span><code class="xref mat mat-obj docutils literal notranslate"><span class="pre">outfile</span>&#160;&#160;&#160;&#160; <span class="pre">If</span> <span class="pre">present,</span> <span class="pre">the</span> <span class="pre">output</span> <span class="pre">of</span> <span class="pre">func_eval</span> <span class="pre">will</span> <span class="pre">be</span> <span class="pre">written</span> <span class="pre">to</span> <span class="pre">the</span></code></span>) – of the given name/path.
If numel(win) &gt; 1, outfile must be omitted or a cell array of
file paths with equal number of elements as win.</p>
</dd>
</dl>
<dl>
<dt>Additional allowed options:</dt><dd><dl>
<dt>‘all’      Requests that the calculated function be returned over</dt><dd><p>the whole of the domain of the input dataset. If not given, then
the function will be returned only at those points of the dataset
that contain data.</p>
<blockquote>
<div><p>Applies only to input with no pixel information - this option is ignored if</p>
</div></blockquote>
<p>the input is a full sqw object.</p>
</dd>
</dl>
</dd>
</dl>
<blockquote>
<div><p>wout        Output objects or array of objects</p>
</div></blockquote>
<dl>
<dt>e.g.</dt><dd><p>&gt;&gt; wout = func_eval (w, &#64;gauss4d, [ht,x1_0,x2_0,x3_0,x4_0,sig1,sig2,sig3,sig4])</p>
<dl class="simple">
<dt>where the function gauss appears on the matlab path</dt><dd><p>function y = gauss4d (x1, x2, x3, x4, pars)
y = (pars(1)/(sig*sqrt(2*pi))) * …</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.get_proj_and_pbin">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">get_proj_and_pbin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.get_proj_and_pbin" title="Permalink to this definition"></a></dt>
<dd><p>Reverse engineer the projection and binning of an sqw object</p>
<blockquote>
<div><p>&gt;&gt; [proj, pbin] = get_proj_and_pbin (w)</p>
</div></blockquote>
<blockquote>
<div><p>w       sqw object</p>
</div></blockquote>
<blockquote>
<div><p>proj    Projection as a projaxes object
pbin    Cell array, a row length 4, of the binning description of the</p>
<blockquote>
<div><p>sqw object</p>
</div></blockquote>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.log">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.log" title="Permalink to this definition"></a></dt>
<dd><p>Implements log(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = log(w1)</p>
</div></blockquote>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.log10">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">log10</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.log10" title="Permalink to this definition"></a></dt>
<dd><p>Implements log10(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = log10(w1)</p>
</div></blockquote>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.mask">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">mask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">win</span></em>, <em class="sig-param"><span class="pre">mask_array</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.mask" title="Permalink to this definition"></a></dt>
<dd><p>Remove the bins indicated by the mask array</p>
<blockquote>
<div><p>&gt;&gt; wout = mask (win, mask_array)</p>
</div></blockquote>
<blockquote>
<div><p>win                 Input sqw object</p>
<dl>
<dt>mask_array          Array of 1 or 0 (or true or false) that indicate</dt><dd><dl class="simple">
<dt>which points to retain (true to retain, false to ignore)</dt><dd><p>Numeric or logical array of same number of elements</p>
</dd>
<dt>as the <a href="#id9"><span class="problematic" id="id10">data_</span></a>.</dt><dd><p>Note: mask will be applied to the stored data array</p>
</dd>
</dl>
<p>according as the projection axes, not the display axes.
Thus permuting the display axes does not alter the
effect of masking the <a href="#id11"><span class="problematic" id="id12">data_</span></a>.</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>wout                Output dataset.</p>
</div></blockquote>
<p>Original author: T.G.Perring</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.mask_pixels">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">mask_pixels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">win</span></em>, <em class="sig-param"><span class="pre">mask_array</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.mask_pixels" title="Permalink to this definition"></a></dt>
<dd><p>Remove the pixels indicated by the mask array</p>
<blockquote>
<div><p>&gt;&gt; wout = mask_pixels (win, mask_array)     % Mask array
&gt;&gt; wout = mask_pixels (win, wmask)          % Mask according to pixel array</p>
<blockquote>
<div><p>% contents</p>
</div></blockquote>
</div></blockquote>
<blockquote>
<div><p>win                 Input sqw object</p>
<dl>
<dt>mask_array          Array of 1 or 0 (or true or false) that indicate</dt><dd><blockquote>
<div><dl class="simple">
<dt>which pixels to retain (true to retain, false to ignore)</dt><dd><p>Numeric or logical array of same number of pixels</p>
</dd>
<dt>as the data.</dt><dd><p>Note: mask will be applied to the stored data array</p>
</dd>
</dl>
<p>according as the projection axes, not the display axes.
Thus permuting the display axes does not alter the
effect of masking the data.</p>
</div></blockquote>
<p><em>OR</em></p>
</dd>
<dt>wmask               sqw object in which the signal in individual pixels is</dt><dd><dl>
<dt>interpreted as a mask array:</dt><dd><blockquote>
<div><p>=1 (or true)  to retain
=0 (or false) to remove</p>
</div></blockquote>
<p>wmask must have the same dimensionality, number of bins</p>
</dd>
</dl>
<p>along each dimension, and number of pixels in each bins
as the array to be masked.</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>wout                Output dataset.</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.mask_points">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">mask_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">win</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.mask_points" title="Permalink to this definition"></a></dt>
<dd><p>Determine the points to keep on the basis of ranges and mask array.</p>
<blockquote>
<div><p>&gt;&gt; sel = mask_points (win, ‘keep’, xkeep, ‘remove’, xremove, ‘mask’, mask)</p>
</div></blockquote>
<p>or any selection (in any order) of the keyword-argument pairs e.g.</p>
<blockquote>
<div><p>&gt;&gt; sel = mask_points (win, ‘mask’, mask, ‘remove’, xremove)</p>
</div></blockquote>
<blockquote>
<div><p>win     Input sqw object</p>
<dl>
<dt>xkeep   Ranges of display axes to retain for fitting. A range is specified by an array</dt><dd><p>of numbers which define a hypercube.
For example in case of two dimensions:</p>
<blockquote>
<div><p>[xlo, xhi, ylo, yhi]</p>
</div></blockquote>
<dl>
<dt>or in the case of n-dimensions:</dt><dd><blockquote>
<div><p>[x1_lo, x1_hi, x2_lo, x2_hi,…, xn_lo, xn_hi]</p>
</div></blockquote>
<dl class="simple">
<dt>e.g. 1D: [50,70]</dt><dd><p>2D: [1,2,130,160]</p>
</dd>
</dl>
</dd>
<dt>More than one range can be defined in rows,</dt><dd><blockquote>
<div><p>[Range_1; Range_2; Range_3;…; Range_m]</p>
</div></blockquote>
<p>where each of the ranges are given in the format above.</p>
</dd>
</dl>
</dd>
</dl>
<p>xremove Ranges of display axes to remove from fitting.</p>
<dl>
<dt>mask    Mask array of same number of elements as data array: 1 to keep, 0 to remove</dt><dd><blockquote>
<div><p>Note: mask will be applied to the stored data array</p>
</div></blockquote>
<p>according as the projection axes, not the display axes.
Thus permuting the display axes does not alter the
effect of masking the <a href="#id13"><span class="problematic" id="id14">data_</span></a>. The mask array works
consistently with the input required by the mask method.</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><blockquote>
<div><p>sel     Mask array of same shape as <a href="#id15"><span class="problematic" id="id16">data_</span></a>. true for bins to keep, false to discard.</p>
</div></blockquote>
<p>Advanced use: in addition the following two arguments, if present, suppress failure or the
display of informational messges. Instead, the messages are returned to be used as desired.</p>
<blockquote>
<div><p>ok      =true if worked, =false if error</p>
<p>mess    messages: if ok=true then informational or warning, if ok=false then the error message</p>
</div></blockquote>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.mask_random_fraction_pixels">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">mask_random_fraction_pixels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">win</span></em>, <em class="sig-param"><span class="pre">npix</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.mask_random_fraction_pixels" title="Permalink to this definition"></a></dt>
<dd><p>reduce the number of pixels randomly in a sqw object</p>
<p>The function uses the mask_pixels() function to keep only a fixed
fraction of pixels randomly chosen. Useful when doing numerically intensive
simulations of sqw objects with sqw_eval or fit_sqw, to speed things up</p>
<p>wout = mask_random_fraction_pixels(win,npix_frac)</p>
<blockquote>
<div><p>win                 Input sqw object</p>
<dl class="simple">
<dt>npix_frac           Fraction of pixels in <a href="#id17"><span class="problematic" id="id18">win.data_</span></a>.pix array to keep.</dt><dd><p>These are chosen at random. If win is an array then
npix can either be a scalar, in which case all
outputs will have the same number of retained
pixels, or an array of the same size as win, in
which case each mask is applied separately.</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>wout                Output dataset.</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.mask_random_pixels">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">mask_random_pixels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">win</span></em>, <em class="sig-param"><span class="pre">npix</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.mask_random_pixels" title="Permalink to this definition"></a></dt>
<dd><p>reduce the number of pixels randomly in a sqw object</p>
<p>The function uses the mask_pixels() function to keep only a fixed amount
of pixels randomly chosen. Useful when doing numerically intensive
simulations of sqw objects with sqw_eval or fit_sqw, to speed things up</p>
<p>wout = mask_random_pixels(win,npix)</p>
<blockquote>
<div><p>win                 Input sqw object</p>
<dl class="simple">
<dt>npix               Number of pixels in <a href="#id19"><span class="problematic" id="id20">win.data_</span></a>.pix array to keep.</dt><dd><p>These are chosen at random. If win is an array then
npix can either be a scalar, in which case all
outputs will have the same number of retained
pixels, or an array of the same size as win, in
which case each mask is applied separately.</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>wout                Output dataset.</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.minus">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">minus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em>, <em class="sig-param"><span class="pre">w2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.minus" title="Permalink to this definition"></a></dt>
<dd><p>Implements w1 - w2 for objects</p>
<blockquote>
<div><p>&gt;&gt; w = w1 - w2</p>
</div></blockquote>
<blockquote>
<div><dl>
<dt>w1, w2      Objects on which the binary operation is to be performed.</dt><dd><p>One of these can be a Matlab double (i.e. double precision)
array, in which case the variance array is taken to be zero.</p>
<p>If w1, w2 are scalar objects with the same signal array sizes:
- The operation is performed element-by-element.</p>
<p>If one of w1 or w2 is a double array (and the other is a
scalar object):
- If a scalar, apply to each element of the object signal.
- If it is an array of the same size as the object signal</p>
<blockquote>
<div><p>array, apply the operation element by element.</p>
</div></blockquote>
<p>If one or both of w1 and w2 are arrays of objects:
- If objects have same array sizes, the binary operation is</p>
<blockquote>
<div><p>applied object element-by-object element.</p>
</div></blockquote>
<ul class="simple">
<li><p>If one of the objects is scalar (i.e. only one object),</p></li>
</ul>
<blockquote>
<div><p>then it is applied by the binary operation to each object
in the other array.</p>
</div></blockquote>
<p>If one of w1, w2 is an array of objects and the other is a
double array:
- If the double is a scalar, it is applied to every object</p>
<blockquote>
<div><p>in the array.</p>
</div></blockquote>
<ul class="simple">
<li><p>If the double is an array with the same size as the object</p></li>
</ul>
<blockquote>
<div><p>array, then each element is applied as a scalar to the
corresponding object in the object array.</p>
</div></blockquote>
<ul class="simple">
<li><p>If the double is an array with larger size than the object</p></li>
</ul>
<blockquote>
<div><p>array, then the array is resolved into a stack of arrays,
where the stack has the same size as the object array, and
the each array in the stack is applied to the corresponding
object in the object array. [Note that for this operation
to be valid, each object must have the same signal array
size.]</p>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.mldivide">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">mldivide</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em>, <em class="sig-param"><span class="pre">w2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.mldivide" title="Permalink to this definition"></a></dt>
<dd><p>Implements w1 w2 for objects</p>
<blockquote>
<div><p>&gt;&gt; w = w1 w2</p>
</div></blockquote>
<blockquote>
<div><dl>
<dt>w1, w2      Objects on which the binary operation is to be performed.</dt><dd><p>One of these can be a Matlab double (i.e. double precision)
array, in which case the variance array is taken to be zero.</p>
<p>If w1, w2 are scalar objects with the same signal array sizes:
- The operation is performed element-by-element.</p>
<p>If one of w1 or w2 is a double array (and the other is a
scalar object):
- If a scalar, apply to each element of the object signal.
- If it is an array of the same size as the object signal</p>
<blockquote>
<div><p>array, apply the operation element by element.</p>
</div></blockquote>
<p>If one or both of w1 and w2 are arrays of objects:
- If objects have same array sizes, the binary operation is</p>
<blockquote>
<div><p>applied object element-by-object element.</p>
</div></blockquote>
<ul class="simple">
<li><p>If one of the objects is scalar (i.e. only one object),</p></li>
</ul>
<blockquote>
<div><p>then it is applied by the binary operation to each object
in the other array.</p>
</div></blockquote>
<p>If one of w1, w2 is an array of objects and the other is a
double array:
- If the double is a scalar, it is applied to every object</p>
<blockquote>
<div><p>in the array.</p>
</div></blockquote>
<ul class="simple">
<li><p>If the double is an array with the same size as the object</p></li>
</ul>
<blockquote>
<div><p>array, then each element is applied as a scalar to the
corresponding object in the object array.</p>
</div></blockquote>
<ul class="simple">
<li><p>If the double is an array with larger size than the object</p></li>
</ul>
<blockquote>
<div><p>array, then the array is resolved into a stack of arrays,
where the stack has the same size as the object array, and
the each array in the stack is applied to the corresponding
object in the object array. [Note that for this operation
to be valid, each object must have the same signal array
size.]</p>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.mpower">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">mpower</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em>, <em class="sig-param"><span class="pre">w2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.mpower" title="Permalink to this definition"></a></dt>
<dd><p>Implements w1 ^ w2 for objects</p>
<blockquote>
<div><p>&gt;&gt; w = w1 ^ w2</p>
</div></blockquote>
<blockquote>
<div><dl>
<dt>w1, w2      Objects on which the binary operation is to be performed.</dt><dd><p>One of these can be a Matlab double (i.e. double precision)
array, in which case the variance array is taken to be zero.</p>
<p>If w1, w2 are scalar objects with the same signal array sizes:
- The operation is performed element-by-element.</p>
<p>If one of w1 or w2 is a double array (and the other is a
scalar object):
- If a scalar, apply to each element of the object signal.
- If it is an array of the same size as the object signal</p>
<blockquote>
<div><p>array, apply the operation element by element.</p>
</div></blockquote>
<p>If one or both of w1 and w2 are arrays of objects:
- If objects have same array sizes, the binary operation is</p>
<blockquote>
<div><p>applied object element-by-object element.</p>
</div></blockquote>
<ul class="simple">
<li><p>If one of the objects is scalar (i.e. only one object),</p></li>
</ul>
<blockquote>
<div><p>then it is applied by the binary operation to each object
in the other array.</p>
</div></blockquote>
<p>If one of w1, w2 is an array of objects and the other is a
double array:
- If the double is a scalar, it is applied to every object</p>
<blockquote>
<div><p>in the array.</p>
</div></blockquote>
<ul class="simple">
<li><p>If the double is an array with the same size as the object</p></li>
</ul>
<blockquote>
<div><p>array, then each element is applied as a scalar to the
corresponding object in the object array.</p>
</div></blockquote>
<ul class="simple">
<li><p>If the double is an array with larger size than the object</p></li>
</ul>
<blockquote>
<div><p>array, then the array is resolved into a stack of arrays,
where the stack has the same size as the object array, and
the each array in the stack is applied to the corresponding
object in the object array. [Note that for this operation
to be valid, each object must have the same signal array
size.]</p>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.mrdivide">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">mrdivide</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em>, <em class="sig-param"><span class="pre">w2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.mrdivide" title="Permalink to this definition"></a></dt>
<dd><p>Implements w1 / w2 for objects</p>
<blockquote>
<div><p>&gt;&gt; w = w1 / w2</p>
</div></blockquote>
<blockquote>
<div><dl>
<dt>w1, w2      Objects on which the binary operation is to be performed.</dt><dd><p>One of these can be a Matlab double (i.e. double precision)
array, in which case the variance array is taken to be zero.</p>
<p>If w1, w2 are scalar objects with the same signal array sizes:
- The operation is performed element-by-element.</p>
<p>If one of w1 or w2 is a double array (and the other is a
scalar object):
- If a scalar, apply to each element of the object signal.
- If it is an array of the same size as the object signal</p>
<blockquote>
<div><p>array, apply the operation element by element.</p>
</div></blockquote>
<p>If one or both of w1 and w2 are arrays of objects:
- If objects have same array sizes, the binary operation is</p>
<blockquote>
<div><p>applied object element-by-object element.</p>
</div></blockquote>
<ul class="simple">
<li><p>If one of the objects is scalar (i.e. only one object),</p></li>
</ul>
<blockquote>
<div><p>then it is applied by the binary operation to each object
in the other array.</p>
</div></blockquote>
<p>If one of w1, w2 is an array of objects and the other is a
double array:
- If the double is a scalar, it is applied to every object</p>
<blockquote>
<div><p>in the array.</p>
</div></blockquote>
<ul class="simple">
<li><p>If the double is an array with the same size as the object</p></li>
</ul>
<blockquote>
<div><p>array, then each element is applied as a scalar to the
corresponding object in the object array.</p>
</div></blockquote>
<ul class="simple">
<li><p>If the double is an array with larger size than the object</p></li>
</ul>
<blockquote>
<div><p>array, then the array is resolved into a stack of arrays,
where the stack has the same size as the object array, and
the each array in the stack is applied to the corresponding
object in the object array. [Note that for this operation
to be valid, each object must have the same signal array
size.]</p>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.mtimes">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">mtimes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em>, <em class="sig-param"><span class="pre">w2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.mtimes" title="Permalink to this definition"></a></dt>
<dd><p>Implements w1 * w2 for objects</p>
<blockquote>
<div><p>&gt;&gt; w = w1 * w2</p>
</div></blockquote>
<blockquote>
<div><dl>
<dt>w1, w2      Objects on which the binary operation is to be performed.</dt><dd><p>One of these can be a Matlab double (i.e. double precision)
array, in which case the variance array is taken to be zero.</p>
<p>If w1, w2 are scalar objects with the same signal array sizes:
- The operation is performed element-by-element.</p>
<p>If one of w1 or w2 is a double array (and the other is a
scalar object):
- If a scalar, apply to each element of the object signal.
- If it is an array of the same size as the object signal</p>
<blockquote>
<div><p>array, apply the operation element by element.</p>
</div></blockquote>
<p>If one or both of w1 and w2 are arrays of objects:
- If objects have same array sizes, the binary operation is</p>
<blockquote>
<div><p>applied object element-by-object element.</p>
</div></blockquote>
<ul class="simple">
<li><p>If one of the objects is scalar (i.e. only one object),</p></li>
</ul>
<blockquote>
<div><p>then it is applied by the binary operation to each object
in the other array.</p>
</div></blockquote>
<p>If one of w1, w2 is an array of objects and the other is a
double array:
- If the double is a scalar, it is applied to every object</p>
<blockquote>
<div><p>in the array.</p>
</div></blockquote>
<ul class="simple">
<li><p>If the double is an array with the same size as the object</p></li>
</ul>
<blockquote>
<div><p>array, then each element is applied as a scalar to the
corresponding object in the object array.</p>
</div></blockquote>
<ul class="simple">
<li><p>If the double is an array with larger size than the object</p></li>
</ul>
<blockquote>
<div><p>array, then the array is resolved into a stack of arrays,
where the stack has the same size as the object array, and
the each array in the stack is applied to the corresponding
object in the object array. [Note that for this operation
to be valid, each object must have the same signal array
size.]</p>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.multifit_func">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">multifit_func</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.multifit_func" title="Permalink to this definition"></a></dt>
<dd><p>Simultaneously fit function(s) to one or more sqw objects</p>
<blockquote>
<div><blockquote>
<div><p>&gt;&gt; myobj = multifit_func (w1, w2, …)      % w1, w2 objects or arrays of objects</p>
</div></blockquote>
<p>This creates a fitting object of class mfclass_Horace with the provided data,
which can then be manipulated to add further data, set the fitting
functions, initial parameter values etc. and fit or simulate the data.
For details about how to do this  &lt;a href=”matlab:help(‘mfclass_Horace’);”&gt;Click here&lt;/a&gt;</p>
<p>For example:</p>
<blockquote>
<div><dl class="simple">
<dt>&gt;&gt; myobj = multifit_func (w1, w2, …); % set the data</dt><dd><p>:</p>
</dd>
</dl>
<p>&gt;&gt; myobj = myobj.set_fun (&#64;function_name, pars);  % set forgraound function(s)
&gt;&gt; myobj = myobj.set_bfun (&#64;function_name, pars); % set background function(s)</p>
<blockquote>
<div><p>:</p>
</div></blockquote>
<p>&gt;&gt; myobj = myobj.set_free (pfree);      % set which parameters are floating
&gt;&gt; myobj = myobj.set_bfree (bpfree);    % set which parameters are floating
&gt;&gt; [wfit,fitpars] = myobj.fit;          % perform fit</p>
</div></blockquote>
<p>This method fits function(s) of the plot axes for both the foreground and
the background function(s). The format of the fit functions depends on
the number of plot axes for each sqw object. For examples see:
&lt;a href=”matlab:edit(‘example_1d_function’);”&gt;example_1d_function&lt;/a&gt;
&lt;a href=”matlab:edit(‘example_2d_function’);”&gt;example_2d_function&lt;/a&gt;
&lt;a href=”matlab:edit(‘example_3d_function’);”&gt;example_3d_function&lt;/a&gt;</p>
<p>See also multifit_sqw multifit_sqw_sqw</p>
</div></blockquote>
<dl class="simple">
<dt>[Help for legacy use (2017 and earlier):</dt><dd><p>If you are still using the legacy version then it is strongly recommended
that you change to the new operation. Help for the legacy operation can
be &lt;a href=”matlab:help(‘sqw/multifit_legacy_func’);”&gt;found here&lt;/a&gt;]</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.multifit_sqw">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">multifit_sqw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.multifit_sqw" title="Permalink to this definition"></a></dt>
<dd><p>Simultaneously fit function(s) of S(Q,w)to one or more sqw objects</p>
<blockquote>
<div><blockquote>
<div><p>&gt;&gt; myobj = multifit_sqw (w1, w2, …)      % w1, w2 objects or arrays of objects</p>
</div></blockquote>
<p>This creates a fitting object of class mfclass_Horace_sqw with the provided data,
which can then be manipulated to add further data, set the fitting
functions, initial parameter values etc. and fit or simulate the data.
For details about how to do this  &lt;a href=”matlab:help(‘mfclass_Horace_sqw’);”&gt;Click here&lt;/a&gt;</p>
<p>For example:</p>
<blockquote>
<div><dl class="simple">
<dt>&gt;&gt; myobj = multifit_sqw (w1, w2, …); % set the data</dt><dd><p>:</p>
</dd>
</dl>
<p>&gt;&gt; myobj = myobj.set_fun (&#64;function_name, pars);  % set forgraound function(s)
&gt;&gt; myobj = myobj.set_bfun (&#64;function_name, pars); % set background function(s)</p>
<blockquote>
<div><p>:</p>
</div></blockquote>
<p>&gt;&gt; myobj = myobj.set_free (pfree);      % set which parameters are floating
&gt;&gt; myobj = myobj.set_bfree (bpfree);    % set which parameters are floating
&gt;&gt; [wfit,fitpars] = myobj.fit;          % perform fit</p>
</div></blockquote>
<p>This method fits model(s) for S(Q,w) as the foreground function(s), and
function(s) of the plot axes for the background function(s)</p>
<p>For the format of foreground fit functions:
&lt;a href=”matlab:edit(‘example_sqw_spin_waves’);”&gt;Damped spin waves&lt;/a&gt;
&lt;a href=”matlab:edit(‘example_sqw_flat_mode’);”&gt;Dispersionless excitations&lt;/a&gt;</p>
<p>The format of the background fit functions depends on the number of plot
axes for each sqw object. For examples see:
&lt;a href=”matlab:edit(‘example_1d_function’);”&gt;example_1d_function&lt;/a&gt;
&lt;a href=”matlab:edit(‘example_2d_function’);”&gt;example_2d_function&lt;/a&gt;
&lt;a href=”matlab:edit(‘example_3d_function’);”&gt;example_3d_function&lt;/a&gt;</p>
<p>See also multifit multifit_sqw_sqw</p>
</div></blockquote>
<dl class="simple">
<dt>[Help for legacy use (2017 and earlier):</dt><dd><p>If you are still using the legacy version then it is strongly recommended
that you change to the new operation. Help for the legacy operation can
be &lt;a href=”matlab:help(‘sqw/multifit_legacy_sqw’);”&gt;found here&lt;/a&gt;]</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.multifit_sqw_sqw">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">multifit_sqw_sqw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.multifit_sqw_sqw" title="Permalink to this definition"></a></dt>
<dd><p>Simultaneously fit function(s) of S(Q,w)to one or more sqw objects</p>
<blockquote>
<div><blockquote>
<div><p>&gt;&gt; myobj = multifit_sqw_sqw (w1, w2, …)      % w1, w2 objects or arrays of objects</p>
</div></blockquote>
<p>This creates a fitting object of class mfclass_Horace_sqw_sqw with the provided data,
which can then be manipulated to add further data, set the fitting
functions, initial parameter values etc. and fit or simulate the data.
For details about how to do this  &lt;a href=”matlab:help(‘mfclass_Horace_sqw_sqw’);”&gt;Click here&lt;/a&gt;</p>
<p>For example:</p>
<blockquote>
<div><dl class="simple">
<dt>&gt;&gt; myobj = multifit_sqw_sqw (w1, w2, …); % set the data</dt><dd><p>:</p>
</dd>
</dl>
<p>&gt;&gt; myobj = myobj.set_fun (&#64;function_name, pars);  % set forgraound function(s)
&gt;&gt; myobj = myobj.set_bfun (&#64;function_name, pars); % set background function(s)</p>
<blockquote>
<div><p>:</p>
</div></blockquote>
<p>&gt;&gt; myobj = myobj.set_free (pfree);      % set which parameters are floating
&gt;&gt; myobj = myobj.set_bfree (bpfree);    % set which parameters are floating
&gt;&gt; [wfit,fitpars] = myobj.fit;          % perform fit</p>
</div></blockquote>
<p>This method fits function(s) of S(Q,w) as both the foreground and
the background function(s). For the format of the fit functions:
&lt;a href=”matlab:edit(‘example_sqw_spin_waves’);”&gt;Damped spin waves&lt;/a&gt;
&lt;a href=”matlab:edit(‘example_sqw_flat_mode’);”&gt;Dispersionless excitations&lt;/a&gt;</p>
<p>See also multifit multifit_sqw</p>
</div></blockquote>
<dl class="simple">
<dt>[Help for legacy use (2017 and earlier):</dt><dd><p>If you are still using the legacy version then it is strongly recommended
that you change to the new operation. Help for the legacy operation can
be &lt;a href=”matlab:help(‘sqw/multifit_legacy_sqw_sqw’);”&gt;found here&lt;/a&gt;]</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.pa">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">pa</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.pa" title="Permalink to this definition"></a></dt>
<dd><p>Overplot an area plot of a 2D sqw dataset or array of datasets</p>
<blockquote>
<div><p>&gt;&gt; pa(w)</p>
</div></blockquote>
<dl class="simple">
<dt>Advanced use:</dt><dd><dl class="simple">
<dt>&gt;&gt; pa(w,’name’,fig_name)        % overplot on figure with name = fig_name</dt><dd><p>% or figure with given figure number or handle</p>
</dd>
</dl>
</dd>
<dt>Return figure, axes and plot handles:</dt><dd><p>&gt;&gt; [fig_handle, axes_handle, plot_handle] = pa(w,…)</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.paoc">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">paoc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.paoc" title="Permalink to this definition"></a></dt>
<dd><p>Overplot an area plot of a 2D sqw dataset or array of datasets on the current figure</p>
<blockquote>
<div><p>&gt;&gt; paoc(w)</p>
</div></blockquote>
<dl class="simple">
<dt>Return figure, axes and plot handles:</dt><dd><p>&gt;&gt; [fig_handle, axes_handle, plot_handle] = paoc(w)</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.pd">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">pd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.pd" title="Permalink to this definition"></a></dt>
<dd><p>Overplot markers, error bars and lines for a 1D sqw object or array of objects on an existing plot</p>
<blockquote>
<div><p>&gt;&gt; pd(w)</p>
</div></blockquote>
<dl class="simple">
<dt>Advanced use:</dt><dd><dl class="simple">
<dt>&gt;&gt; pd(w,’name’,fig_name)        % overplot on figure with name = fig_name</dt><dd><p>% or figure with given figure number or handle</p>
</dd>
</dl>
</dd>
<dt>Return figure, axes and plot handles:</dt><dd><p>&gt;&gt; [fig_handle, axes_handle, plot_handle] = pd(w,…)</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.pdoc">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">pdoc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.pdoc" title="Permalink to this definition"></a></dt>
<dd><p>Overplot markers, error bars and lines for a 1D sqw object or array of objects on the current plot</p>
<blockquote>
<div><p>&gt;&gt; pdoc(w)</p>
</div></blockquote>
<dl class="simple">
<dt>Return figure, axes and plot handles:</dt><dd><p>&gt;&gt; [fig_handle, axes_handle, plot_handle] = pdoc(w)</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.pe">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">pe</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.pe" title="Permalink to this definition"></a></dt>
<dd><p>Overplot error bars for a 1D sqw object or array of objects on an existing plot</p>
<blockquote>
<div><p>&gt;&gt; pe(w)</p>
</div></blockquote>
<dl class="simple">
<dt>Advanced use:</dt><dd><dl class="simple">
<dt>&gt;&gt; pe(w,’name’,fig_name)        % overplot on figure with name = fig_name</dt><dd><p>% or figure with given figure number or handle</p>
</dd>
</dl>
</dd>
<dt>Return figure, axes and plot handles:</dt><dd><p>&gt;&gt; [fig_handle, axes_handle, plot_handle] = pe(w,…)</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.peoc">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">peoc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.peoc" title="Permalink to this definition"></a></dt>
<dd><p>Overplot error bars for a 1D sqw object or array of objects on the current plot</p>
<blockquote>
<div><p>&gt;&gt; peoc(w)</p>
</div></blockquote>
<dl class="simple">
<dt>Return figure, axes and plot handles:</dt><dd><p>&gt;&gt; [fig_handle, axes_handle, plot_handle] = peoc(w)</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.ph">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">ph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.ph" title="Permalink to this definition"></a></dt>
<dd><p>Overplot histogram for a 1D sqw object or array of objects on an existing plot</p>
<blockquote>
<div><p>&gt;&gt; ph(w)</p>
</div></blockquote>
<dl class="simple">
<dt>Advanced use:</dt><dd><dl class="simple">
<dt>&gt;&gt; ph(w,’name’,fig_name)        % overplot on figure with name = fig_name</dt><dd><p>% or figure with given figure number or handle</p>
</dd>
</dl>
</dd>
<dt>Return figure, axes and plot handles:</dt><dd><p>&gt;&gt; [fig_handle, axes_handle, plot_handle] = ph(w,…)</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.phoc">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">phoc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.phoc" title="Permalink to this definition"></a></dt>
<dd><p>Overplot histogram for a 1D sqw object or array of objects on the current plot</p>
<blockquote>
<div><p>&gt;&gt; phoc(w)</p>
</div></blockquote>
<dl class="simple">
<dt>Return figure, axes and plot handles:</dt><dd><p>&gt;&gt; [fig_handle, axes_handle, plot_handle] = phoc(w)</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.pl">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">pl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.pl" title="Permalink to this definition"></a></dt>
<dd><p>Overplot line for a 1D sqw object or array of objects on an existing plot</p>
<blockquote>
<div><p>&gt;&gt; pl(w)</p>
</div></blockquote>
<dl class="simple">
<dt>Advanced use:</dt><dd><dl class="simple">
<dt>&gt;&gt; pl(w,’name’,fig_name)        % overplot on figure with name = fig_name</dt><dd><p>% or figure with given figure number or handle</p>
</dd>
</dl>
</dd>
<dt>Return figure, axes and plot handles:</dt><dd><p>&gt;&gt; [fig_handle, axes_handle, plot_handle] = pl(w,…)</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.ploc">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">ploc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.ploc" title="Permalink to this definition"></a></dt>
<dd><p>Overplot line for a 1D sqw object or array of objects on the current plot</p>
<blockquote>
<div><p>&gt;&gt; ploc(w)</p>
</div></blockquote>
<dl class="simple">
<dt>Return figure, axes and plot handles:</dt><dd><p>&gt;&gt; [fig_handle, axes_handle, plot_handle] = ploc(w)</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.plot">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.plot" title="Permalink to this definition"></a></dt>
<dd><p>Plot 1D, 2D or 3D sqw object or array of objects</p>
<blockquote>
<div><p>&gt;&gt; plot(w)
&gt;&gt; plot(w,opt1,opt2,…)    % plot with optional arguments</p>
</div></blockquote>
<dl>
<dt>Equivalent to:</dt><dd><p>&gt;&gt; dp(w)                % 1D dataset
&gt;&gt; dp(w,…)</p>
<p>&gt;&gt; da(w)                % 2D dataset
&gt;&gt; da(w,…)</p>
<p>&gt;&gt; sliceomatic(w)       % 3D dataset
&gt;&gt; sliceomatic(w,…)</p>
</dd>
</dl>
<p>For details of optional parameters type &gt;&gt; help sqw/dp, &gt;&gt; help sqw/da,
or &gt;&gt; help sqw/sliceomatic as appropriate</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.plotover">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">plotover</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.plotover" title="Permalink to this definition"></a></dt>
<dd><p>Overplot 1D, 2D or 3D sqw object or array of objects</p>
<blockquote>
<div><p>&gt;&gt; plotover(w)
&gt;&gt; plotover(w,opt1,opt2,…)    % plot with optional arguments</p>
</div></blockquote>
<dl>
<dt>Equivalent to:</dt><dd><p>&gt;&gt; pp(w)                % 1D dataset
&gt;&gt; pp(w,…)</p>
<p>&gt;&gt; pa(w)                % 2D dataset
&gt;&gt; pa(w,…)</p>
</dd>
</dl>
<p>For details of optional parameters type &gt;&gt; help sqw/pp, &gt;&gt; help sqw/pa,
as appropriate</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.plus">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">plus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em>, <em class="sig-param"><span class="pre">w2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.plus" title="Permalink to this definition"></a></dt>
<dd><p>Implements w1 + w2 for objects</p>
<blockquote>
<div><p>&gt;&gt; w = w1 + w2</p>
</div></blockquote>
<blockquote>
<div><dl>
<dt>w1, w2      Objects on which the binary operation is to be performed.</dt><dd><p>One of these can be a Matlab double (i.e. double precision)
array, in which case the variance array is taken to be zero.</p>
<p>If w1, w2 are scalar objects with the same signal array sizes:
- The operation is performed element-by-element.</p>
<p>If one of w1 or w2 is a double array (and the other is a
scalar object):
- If a scalar, apply to each element of the object signal.
- If it is an array of the same size as the object signal</p>
<blockquote>
<div><p>array, apply the operation element by element.</p>
</div></blockquote>
<p>If one or both of w1 and w2 are arrays of objects:
- If objects have same array sizes, the binary operation is</p>
<blockquote>
<div><p>applied object element-by-object element.</p>
</div></blockquote>
<ul class="simple">
<li><p>If one of the objects is scalar (i.e. only one object),</p></li>
</ul>
<blockquote>
<div><p>then it is applied by the binary operation to each object
in the other array.</p>
</div></blockquote>
<p>If one of w1, w2 is an array of objects and the other is a
double array:
- If the double is a scalar, it is applied to every object</p>
<blockquote>
<div><p>in the array.</p>
</div></blockquote>
<ul class="simple">
<li><p>If the double is an array with the same size as the object</p></li>
</ul>
<blockquote>
<div><p>array, then each element is applied as a scalar to the
corresponding object in the object array.</p>
</div></blockquote>
<ul class="simple">
<li><p>If the double is an array with larger size than the object</p></li>
</ul>
<blockquote>
<div><p>array, then the array is resolved into a stack of arrays,
where the stack has the same size as the object array, and
the each array in the stack is applied to the corresponding
object in the object array. [Note that for this operation
to be valid, each object must have the same signal array
size.]</p>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.pm">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">pm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.pm" title="Permalink to this definition"></a></dt>
<dd><p>Overplot markers for a 1D sqw object or array of objects on an existing plot</p>
<blockquote>
<div><p>&gt;&gt; pm(w)</p>
</div></blockquote>
<dl class="simple">
<dt>Advanced use:</dt><dd><dl class="simple">
<dt>&gt;&gt; pm(w,’name’,fig_name)        % overplot on figure with name = fig_name</dt><dd><p>% or figure with given figure number or handle</p>
</dd>
</dl>
</dd>
<dt>Return figure, axes and plot handles:</dt><dd><p>&gt;&gt; [fig_handle, axes_handle, plot_handle] = pm(w,…)</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.pmoc">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">pmoc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.pmoc" title="Permalink to this definition"></a></dt>
<dd><p>Overplot markers for a 1D sqw object or array of objects on the current plot</p>
<blockquote>
<div><p>&gt;&gt; pmoc(w)</p>
</div></blockquote>
<dl class="simple">
<dt>Return figure, axes and plot handles:</dt><dd><p>&gt;&gt; [fig_handle, axes_handle, plot_handle] = pmoc(w)</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.pp">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">pp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.pp" title="Permalink to this definition"></a></dt>
<dd><p>Overplot markers and error bars for a 1D sqw object or array of objects on an existing plot</p>
<blockquote>
<div><p>&gt;&gt; pp(w)</p>
</div></blockquote>
<dl class="simple">
<dt>Advanced use:</dt><dd><dl class="simple">
<dt>&gt;&gt; pp(w,’name’,fig_name)        % overplot on figure with name = fig_name</dt><dd><p>% or figure with given figure number or handle</p>
</dd>
</dl>
</dd>
<dt>Return figure, axes and plot handles:</dt><dd><p>&gt;&gt; [fig_handle, axes_handle, plot_handle] = pp(w,…)</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.ppoc">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">ppoc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.ppoc" title="Permalink to this definition"></a></dt>
<dd><p>Overplot markers and error bars for a 1D sqw object or array of objects on the current plot</p>
<blockquote>
<div><p>&gt;&gt; ppoc(w)</p>
</div></blockquote>
<dl class="simple">
<dt>Return figure, axes and plot handles:</dt><dd><p>&gt;&gt; [fig_handle, axes_handle, plot_handle] = ppoc(w)</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.ps">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">ps</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.ps" title="Permalink to this definition"></a></dt>
<dd><p>Overplot a surface plot of a 2D sqw dataset or array of datasets</p>
<blockquote>
<div><p>&gt;&gt; ps(w)</p>
</div></blockquote>
<dl class="simple">
<dt>Advanced use:</dt><dd><dl class="simple">
<dt>&gt;&gt; ps(w,’name’,fig_name)        % overplot on figure with name = fig_name</dt><dd><p>% or figure with given figure number or handle</p>
</dd>
</dl>
</dd>
<dt>Return figure, axes and plot handles:</dt><dd><p>&gt;&gt; [fig_handle, axes_handle, plot_handle] = ps(w,…)</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.ps2">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">ps2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.ps2" title="Permalink to this definition"></a></dt>
<dd><p>Overplot a surface plot of a 2D sqw dataset or array of datasets</p>
<blockquote>
<div><p>&gt;&gt; ps2(w)       % Use error bars to set colour scale
&gt;&gt; ps2(w,wc)    % Signal in wc sets colour scale</p>
<blockquote>
<div><p>%   wc can be any object with a signal array with same
%  size as w, e.g. sqw object, IX_dataset_2d object, or
%  a numeric array.
%   - If w is an array of objects, then wc must contain
%     the same number of objects.
%   - If wc is a numeric array then w must be a scalar
%     object.</p>
</div></blockquote>
</div></blockquote>
<p>Differs from ds in that the signal sets the z axis, and the colouring is
set by the error bars, or by another object. This enables two related
functions to be plotted (e.g. dispersion relation where the ‘signal’
array holds the energy and the error array holds the spectral weight).</p>
<dl class="simple">
<dt>Advanced use:</dt><dd><dl class="simple">
<dt>&gt;&gt; ps(w,’name’,fig_name)        % overplot on figure with name = fig_name</dt><dd><p>% or figure with given figure number or handle</p>
</dd>
</dl>
</dd>
<dt>Return figure, axes and plot handles:</dt><dd><p>&gt;&gt; [fig_handle, axes_handle, plot_handle] = ps2(w,…)</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.ps2oc">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">ps2oc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.ps2oc" title="Permalink to this definition"></a></dt>
<dd><p>Overplot a surface plot of a 2D sqw dataset or array of datasets on the current figure
The colour scale comes from a second source</p>
<blockquote>
<div><p>&gt;&gt; ps2oc(w)     % Use error bars to set colour scale
&gt;&gt; ps2oc(w,wc)  % Signal in wc sets colour scale</p>
<blockquote>
<div><p>%   wc can be any object with a signal array with same
%  size as w, e.g. sqw object, IX_dataset_2d object, or
%  a numeric array.
%   - If w is an array of objects, then wc must contain
%     the same number of objects.
%   - If wc is a numeric array then w must be a scalar
%     object.</p>
</div></blockquote>
</div></blockquote>
<p>Differs from ds in that the signal sets the z axis, and the colouring is
set by the error bars, or by another object. This enables two related
functions to be plotted (e.g. dispersion relation where the ‘signal’
array holds the energy and the error array holds the spectral weight).</p>
<dl class="simple">
<dt>Return figure, axes and plot handles:</dt><dd><p>&gt;&gt; [fig_handle, axes_handle, plot_handle] = ps2oc(w)</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.psoc">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">psoc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.psoc" title="Permalink to this definition"></a></dt>
<dd><p>Overplot a surface plot of a 2D sqw dataset or array of datasets on the current figure</p>
<blockquote>
<div><p>&gt;&gt; psoc(w)</p>
</div></blockquote>
<dl class="simple">
<dt>Return figure, axes and plot handles:</dt><dd><p>&gt;&gt; [fig_handle, axes_handle, plot_handle] = psoc(w)</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.recompute_bin_data">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">recompute_bin_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.recompute_bin_data" title="Permalink to this definition"></a></dt>
<dd><p>Given sqw_type object, recompute w.data.s and w.data.e from the contents of pix array</p>
<p>&gt;&gt; wout=recompute_bin_data(w)</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.save">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">save</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.save" title="Permalink to this definition"></a></dt>
<dd><p>Save a sqw object or array of sqw objects to file</p>
<blockquote>
<div><p>&gt;&gt; save (w)              % prompt for file
&gt;&gt; save (w, file)        % give file
&gt;&gt; save (w, file,loader) % save file using specific data loader</p>
<blockquote>
<div><p>(-update option, is provided, will be
ignored)</p>
</div></blockquote>
<dl class="simple">
<dt>&gt;&gt; save (w, file,’-update’) % if the target file exist, update it to</dt><dd><p>latest format if this is possible. If
update is possible, pixels in file will not be
overwritten.</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>Input:</dt><dd><p>w       sqw object
file    [optional] File for output. if none given, then prompted for a file</p>
<p>Note that if w is an array of sqw objects then file must be a cell
array of filenames of the same size.</p>
</dd>
</dl>
<p>Output:</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.sec">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">sec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.sec" title="Permalink to this definition"></a></dt>
<dd><p>Implements sec(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = sec(w1)</p>
</div></blockquote>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.sech">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">sech</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.sech" title="Permalink to this definition"></a></dt>
<dd><p>Implements sech(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = sech(w1)</p>
</div></blockquote>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.sigvar_get">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">sigvar_get</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.sigvar_get" title="Permalink to this definition"></a></dt>
<dd><p>Get signal and variance from object, and a logical array of which values to ignore</p>
<p>&gt;&gt; [s,var,mask_null] = sigvar_get (w)</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.sin">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">sin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.sin" title="Permalink to this definition"></a></dt>
<dd><p>Implements sin(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = sin(w1)</p>
</div></blockquote>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.sinh">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">sinh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.sinh" title="Permalink to this definition"></a></dt>
<dd><p>Implements sinh(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = sinh(w1)</p>
</div></blockquote>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.sliceomatic">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">sliceomatic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.sliceomatic" title="Permalink to this definition"></a></dt>
<dd><p>Plots 3D sqw object using sliceomatic</p>
<blockquote>
<div><p>&gt;&gt; sliceomatic (w)
&gt;&gt; sliceomatic (w, ‘isonormals’, true)     % to enable isonormals</p>
<dl class="simple">
<dt>&gt;&gt; sliceomatic (w,…,’-noaspect’)  % Do not change aspect ratio</dt><dd><p>% according to data axes unit lengths</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>To get handles to the graphics figure:</dt><dd><p>&gt;&gt; [<a href="#id21"><span class="problematic" id="id22">figureHandle_</span></a>, <a href="#id23"><span class="problematic" id="id24">axesHandle_</span></a>, <a href="#id25"><span class="problematic" id="id26">plotHandle_</span></a>] = sliceomatic(w,…)</p>
</dd>
</dl>
<p>NOTES:</p>
<ul class="simple">
<li><dl class="simple">
<dt>Ensure that the slice color plotting is in ‘texture’ mode -</dt><dd><p>On the ‘AllSlices’ menu click ‘Color Texture’. No indication will
be made on this menu to show that it has been selected, but you can
see the result if you right-click on an arrow indicating a slice on
the graphics window.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>To set the default for future Sliceomatic sessions -</dt><dd><p>On the ‘Object_Defaults’ menu select ‘Slice Color Texture’</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.sliceomatic_overview">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">sliceomatic_overview</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.sliceomatic_overview" title="Permalink to this definition"></a></dt>
<dd><p>Plots 3D sqw object using sliceomatic with view straight down one of the axes</p>
<blockquote>
<div><p>&gt;&gt; sliceomatic_overview (w)         % down third (vertical) axis
&gt;&gt; sliceomatic_overview (w, axis)   % down axis of choice (axis=1,2 or 3)</p>
<p>&gt;&gt; sliceomatic_overview (w,… ‘isonormals’, true) % to enable isonormals</p>
<dl class="simple">
<dt>&gt;&gt; sliceomatic_overview (w,…,’-noaspect’)  % Do not change aspect ratio</dt><dd><p>% according to data axes unit lengths</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>To get handles to the graphics figure:</dt><dd><p>&gt;&gt; [<a href="#id27"><span class="problematic" id="id28">figureHandle_</span></a>, <a href="#id29"><span class="problematic" id="id30">axesHandle_</span></a>, <a href="#id31"><span class="problematic" id="id32">plotHandle_</span></a>] = sliceomatic(w,…)</p>
</dd>
</dl>
<p>Do a sliceomatic plot, but set the axes so that we look straight down the
chosen axis, so that when the slider is moved we get a series of
what appear to be 2d slices.</p>
<p>NOTES:</p>
<ul class="simple">
<li><dl class="simple">
<dt>Ensure that the slice color plotting is in ‘texture’ mode -</dt><dd><p>On the ‘AllSlices’ menu click ‘Color Texture’. No indication will
be made on this menu to show that it has been selected, but you can
see the result if you right-click on an arrow indicating a slice on
the graphics window.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>To set the default for future Sliceomatic sessions -</dt><dd><p>On the ‘Object_Defaults’ menu select ‘Slice Color Texture’</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.smooth">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">smooth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">win</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.smooth" title="Permalink to this definition"></a></dt>
<dd><p>Smooth method - gataway to dnd object smoothing only.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.smooth_units">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">smooth_units</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">win</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.smooth_units" title="Permalink to this definition"></a></dt>
<dd><p>Smooth method - gataway to dnd object smoothing only.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.sqrt">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">sqrt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.sqrt" title="Permalink to this definition"></a></dt>
<dd><p>Implements sqrt(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = sqrt(w1)</p>
</div></blockquote>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.sqw_eval">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">sqw_eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">win</span></em>, <em class="sig-param"><span class="pre">sqwfunc</span></em>, <em class="sig-param"><span class="pre">pars</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.sqw_eval" title="Permalink to this definition"></a></dt>
<dd><p>Calculate sqw for a model scattering function</p>
<blockquote>
<div><blockquote>
<div><p>&gt;&gt; wout = sqw_eval(win, sqwfunc, p)
&gt;&gt; wout = sqw_eval(___, ‘-all’)
&gt;&gt; wout = sqw_eval(___, ‘all’, true)
&gt;&gt; wout = sqw_eval(___, ‘-average’)
&gt;&gt; wout = sqw_eval(___, ‘average’, true)
&gt;&gt; sqw_eval(___, ‘outfile’, outfile)
&gt;&gt; wout = sqw_eval(___, ‘outfile’, outfile)
&gt;&gt; sqw_eval(__, ‘outfile’, outfile, ‘filebacked’, true)
&gt;&gt; wout = sqw_eval(__, ‘filebacked’, true)</p>
</div></blockquote>
<blockquote>
<div><dl>
<dt>win        Dataset (or array of datasets) that provides the axes and points</dt><dd><p>for the calculation</p>
</dd>
<dt>sqwfunc     Handle to function that calculates S(Q, w)</dt><dd><dl>
<dt>Most commonly used form is:</dt><dd><blockquote>
<div><p>weight = sqwfunc (qh, qk, ql, en, p)</p>
</div></blockquote>
<dl>
<dt>where</dt><dd><p>qh,qk,ql,en Arrays containing the coordinates of a set of points
p           Vector of parameters needed by dispersion function</p>
<blockquote>
<div><p>e.g. [A, js, gam] as intensity, exchange, lifetime</p>
</div></blockquote>
<p>weight      Array containing calculated spectral weight</p>
</dd>
</dl>
</dd>
<dt>More general form is:</dt><dd><blockquote>
<div><p>weight = sqwfunc (qh, qk, ql, en, p, c1, c2, ..)</p>
</div></blockquote>
<dl class="simple">
<dt>where</dt><dd><dl class="simple">
<dt>p           Typically a vector of parameters that we might want</dt><dd><p>to fit in a least-squares algorithm</p>
</dd>
<dt>c1, c2, …   Other constant parameters e.g. file name for look-up</dt><dd><p>table</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>pars       Arguments needed by the function. Most commonly, a vector of parameter</dt><dd><p>values e.g. [A, js, gam] as intensity, exchange, lifetime. If a more general
set of parameters is required by the function, then
package these into a cell array and pass that as pars. In the example
above then pars = {p, c1, c2, …}</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><dl>
<dt>outfile    If present, the outputs will be written to the file of the given</dt><dd><p>name/path.
If numel(win) &gt; 1, outfile must either be omitted or be a cell
array of file paths with equal number of elements as win.</p>
</dd>
<dt>all        If true, requests that the calculated sqw be returned over</dt><dd><p>the whole of the domain of the input dataset. If false, then
the function will be returned only at those points of the dataset
that contain <a href="#id33"><span class="problematic" id="id34">data_</span></a>.</p>
<blockquote>
<div><p>Applies only to input with no pixel information - it is ignored if</p>
</div></blockquote>
<p>full sqw object.
[default = false]</p>
</dd>
<dt>average    If true, requests that the calculated sqw be computed for the</dt><dd><p>average values of h, k, l of the pixels in a bin, not for each
pixel individually. Reduces cost of expensive calculations.
Applies only to the case of sqw object with pixel information
- it is ignored if dnd type object.
[default = false]</p>
</dd>
<dt>filebacked  If true, the result of the function will be saved to file and</dt><dd><p>the output will be a file path. If no <cite>outfile</cite> is specified,
a unique path within <cite>tempdir()</cite> will be generated.
Default is false.</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Note: all optional string input parameters can be truncated up to minimal</dt><dd><p>difference between them e.g. routine would accept ‘al’ and
‘av’, ‘ave’, ‘aver’ etc….</p>
</dd>
</dl>
<blockquote>
<div><dl class="simple">
<dt>wout        If <cite>filebacked</cite> is false, an sqw object or array of sqw objects.</dt><dd><p>If <cite>filebacked</cite> is true, a file path or cell array of file paths.
Output argument must be specified if <cite>outfile</cite> not given.</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.sqw_eval_nopix_">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">sqw_eval_nopix_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">obj</span></em>, <em class="sig-param"><span class="pre">sqwfunc</span></em>, <em class="sig-param"><span class="pre">all_bins</span></em>, <em class="sig-param"><span class="pre">pars</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.sqw_eval_nopix_" title="Permalink to this definition"></a></dt>
<dd><p><a href="#id35"><span class="problematic" id="id36">SQW_EVAL_NOPIX_</span></a></p>
<blockquote>
<div><p>Helper function for sqw eval executed on a pixel-less object (i.e. DnD or SQW with no pixels
Called by <cite>sqw_eval_</cite> defined in sqw/DnDBase</p>
<blockquote>
<div><dl class="simple">
<dt>obj        Dataset (or array of datasets) that provides the axes and points</dt><dd><p>for the calculation</p>
</dd>
</dl>
<p>sqwfunc     Handle to function that calculates S(Q,w)
all_bins    Boolean flag wither to apply function to all bins or only those contaiing data
pars       Arguments needed by the function.</p>
</div></blockquote>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.tan">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">tan</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.tan" title="Permalink to this definition"></a></dt>
<dd><p>Implements tan(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = tan(w1)</p>
</div></blockquote>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.tanh">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">tanh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.tanh" title="Permalink to this definition"></a></dt>
<dd><p>Implements tanh(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = tanh(w1)</p>
</div></blockquote>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.uminus">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">uminus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.uminus" title="Permalink to this definition"></a></dt>
<dd><p>Implements uminus(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = uminus(w1)</p>
</div></blockquote>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.uplus">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">uplus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.uplus" title="Permalink to this definition"></a></dt>
<dd><p>Implements uplus(w1) for objects</p>
<blockquote>
<div><p>&gt;&gt; w = uplus(w1)</p>
</div></blockquote>
<blockquote>
<div><dl class="simple">
<dt>w1          Input object or array of objects on which to apply the</dt><dd><p>unary operator.</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>w           Output object or array of objects.</p>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.&#64;SQWDnDBase.xye">
<span class="sig-prename descclassname"><span class="pre">sqw.&#64;SQWDnDBase.</span></span><span class="sig-name descname"><span class="pre">xye</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">w</span></em>, <em class="sig-param"><span class="pre">null_value</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@SQWDnDBase.xye" title="Permalink to this definition"></a></dt>
<dd><p>Get the bin centres, intensity and error bar for a 1D, 2D, 3D or 4D dataset</p>
<blockquote>
<div><p>&gt;&gt; S = xye(w)
&gt;&gt; S = xye(w, null_value)</p>
</div></blockquote>
<blockquote>
<div><p>w       sqw object or array of objects (1D, 2D, 3D or 4D)
null_value  Numeric value to substitute for the intensity in bins</p>
<blockquote>
<div><p>with no data.
Default: NaN</p>
</div></blockquote>
</div></blockquote>
<blockquote>
<div><p>S       Structure with the following fields:</p>
<blockquote>
<div><dl class="simple">
<dt>x   If a 1D sqw object, a column vector with the bin centres</dt><dd><p>Otherwise, a cell array (row vector) of arrays, each array containing the
bin centres for the plot axes. Each array of bin centres
is a column vector.</p>
</dd>
<dt>y   n1 x n2 x… array of intensities, where n1 is the number of</dt><dd><p>bins along the first plot axis, n2 the number of bins along
the second plot axis etc</p>
</dd>
<dt>e   n1 x n2 x… array of error bars, where n1 is the number of</dt><dd><p>bins along the first plot axis, n2 the number of bins along
the second plot axis etc</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
</dd></dl>

</section>
<section id="module-sqw.&#64;Experiment">
<span id="experiment-class"></span><h2><a class="toc-backref" href="#id7"><code class="docutils literal notranslate"><span class="pre">Experiment</span></code> class</a><a class="headerlink" href="#module-sqw.@Experiment" title="Permalink to this headline"></a></h2>
<dl class="mat class">
<dt class="sig sig-object mat" id="sqw.&#64;Experiment.Experiment">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sqw.&#64;Experiment.</span></span><span class="sig-name descname"><span class="pre">Experiment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@Experiment.Experiment" title="Permalink to this definition"></a></dt>
<dd><p>EXPERIMENT Container object for all data describing the Experiment</p>
<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.&#64;Experiment.Experiment.Experiment">
<span class="sig-name descname"><span class="pre">Experiment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@Experiment.Experiment.Experiment" title="Permalink to this definition"></a></dt>
<dd><p>Create a new Experiment object.</p>
<blockquote>
<div><p>obj = Experiment()
obj = Experiment(detector_array[s], instrument[s], sample[s])</p>
</div></blockquote>
<dl class="simple">
<dt>Required:</dt><dd><p>detector_array  Detector array (IX_detector_array objects)
instrument      Instrument (Concrete class inheriting IX_inst)
sample          Sample data (IX_sample object)</p>
</dd>
</dl>
<p>Each argument can be a single object or array of objects.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.&#64;Experiment.Experiment.classVersion">
<span class="sig-name descname"><span class="pre">classVersion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">~</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@Experiment.Experiment.classVersion" title="Permalink to this definition"></a></dt>
<dd><p>define version of the class to store in mat-files
and nxsqw data format. Each new version would presumably read
the older version, so version substitution is based on this
number</p>
</dd></dl>

<dl class="mat staticmethod">
<dt class="sig sig-object mat" id="sqw.&#64;Experiment.Experiment.combine_experiments">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">combine_experiments</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">exp_cellarray</span></em>, <em class="sig-param"><span class="pre">allow_equal_headers</span></em>, <em class="sig-param"><span class="pre">drop_subzone_headers</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@Experiment.Experiment.combine_experiments" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>take cellarray of experiments (e.g., generated from each runfile build</dt><dd><p>during gen_sqw generation)
and combine then together into single Experiment info class</p>
</dd>
</dl>
<p>This is the HACK, providing only basic functionality. Previous
header-s on the basis of sqw_header and part, present in
write_nsqw_to_sqw implementation offers much more.</p>
<dl class="simple">
<dt>TODO: Do proper optinization on the way. See</dt><dd><p>sqw_header.header_combine(header,allow_equal_headers,drop_subzone_headers)</p>
</dd>
<dt>TODO: use allow_equal_headers,drop_subzone_headers variables</dt><dd><p>appropriately</p>
</dd>
<dt>TODO: repeat at least the logic within sqw_header helper class</dt><dd><p>and write_nsqw_to_sqw combine/check headers operation</p>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.&#64;Experiment.Experiment.convert_to_old_headers">
<span class="sig-name descname"><span class="pre">convert_to_old_headers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">header_num</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@Experiment.Experiment.convert_to_old_headers" title="Permalink to this definition"></a></dt>
<dd><p>convert Experiment into the structure suitable to be
stored in old binary sqw files (up to version 3.xxx)</p>
<p>this structure is also used in number of places of the old
code where, e.g., structure sorting is implemented but this
usage is deprecated and will be removed in a future.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.&#64;Experiment.Experiment.get_aver_experiment">
<span class="sig-name descname"><span class="pre">get_aver_experiment</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@Experiment.Experiment.get_aver_experiment" title="Permalink to this definition"></a></dt>
<dd><p>some, presumably average, run-data. Naive implementation,
all data are the same</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.&#64;Experiment.Experiment.get_unique_instruments">
<span class="sig-name descname"><span class="pre">get_unique_instruments</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@Experiment.Experiment.get_unique_instruments" title="Permalink to this definition"></a></dt>
<dd><p>compartibility fields with old binary file formats
TODO: needs proper implementation</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.&#64;Experiment.Experiment.get_unique_samples">
<span class="sig-name descname"><span class="pre">get_unique_samples</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@Experiment.Experiment.get_unique_samples" title="Permalink to this definition"></a></dt>
<dd><p>compartibility fields with old binary file formats
TODO: needs proper implementation</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.&#64;Experiment.Experiment.header_average">
<span class="sig-name descname"><span class="pre">header_average</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@Experiment.Experiment.header_average" title="Permalink to this definition"></a></dt>
<dd><p>very crude implementation for the header, average over all
runs.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.&#64;Experiment.Experiment.indepFields">
<span class="sig-name descname"><span class="pre">indepFields</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">~</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@Experiment.Experiment.indepFields" title="Permalink to this definition"></a></dt>
<dd><p>get independent fields, which fully define the state of the
serializable object.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.&#64;Experiment.Experiment.is_same_ebins">
<span class="sig-name descname"><span class="pre">is_same_ebins</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@Experiment.Experiment.is_same_ebins" title="Permalink to this definition"></a></dt>
<dd><p>return true if all energy bins of all runs are the
same</p>
</dd></dl>

<dl class="mat staticmethod">
<dt class="sig sig-object mat" id="sqw.&#64;Experiment.Experiment.loadobj">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">loadobj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">S</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@Experiment.Experiment.loadobj" title="Permalink to this definition"></a></dt>
<dd><p>boilerplate loadobj method, calling generic method of
saveable class</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.&#64;Experiment.Experiment.set_efix_emode">
<span class="sig-name descname"><span class="pre">set_efix_emode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">efix</span></em>, <em class="sig-param"><span class="pre">emode</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.@Experiment.Experiment.set_efix_emode" title="Permalink to this definition"></a></dt>
<dd><p>change efix and (optionally) emode in all experiment descriptions
if emode is absent or described by any character string,
the emode is kept unchanged</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-sqw.PixelData.&#64;PixelData">
<span id="pixeldata-class"></span><h2><a class="toc-backref" href="#id8"><code class="docutils literal notranslate"><span class="pre">PixelData</span></code> class</a><a class="headerlink" href="#module-sqw.PixelData.@PixelData" title="Permalink to this headline"></a></h2>
<dl class="mat class">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.PixelData">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sqw.PixelData.&#64;PixelData.</span></span><span class="sig-name descname"><span class="pre">PixelData</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">arg</span></em>, <em class="sig-param"><span class="pre">mem_alloc</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.PixelData" title="Permalink to this definition"></a></dt>
<dd><p>PixelData Provides an interface for access to pixel data</p>
<blockquote>
<div><p>This class provides getters and setters for each data column in an SQW
pixel array. You can access the data using the attributes listed below,
using the get_data() method (to retrieve column data) or using the
get_pixels() method (retrieve row data).</p>
<p>Construct this class with an 9 x N array, a file path to an SQW object or
an instance of sqw_binfile_common.</p>
<p>&gt;&gt; pix_data = PixelData(data);
&gt;&gt; pix_data = PixelData(‘/path/to/sqw.sqw’);
&gt;&gt; pix_data = PixelData(‘/path/to/sqw.sqw’, mem_alloc);
&gt;&gt; pix_data = PixelData(faccess_obj);
&gt;&gt; pix_data = PixelData(faccess_obj, mem_alloc);</p>
<p>Constructing via a file or sqw_binfile_common will create a file-backed
data object. No pixel data will be loaded from the file on construction.
Data will be loaded when a getter is called e.g. pix_data.signal. Data will
be loaded in pages such that the data held in memory will not exceed the
size (in bytes) specified by private attribute <a href="#id37"><span class="problematic" id="id38">page_memory_size_</span></a> - this can
be set on construction (see mem_alloc above).</p>
<p>The file-backed operations work by loading “pages” of data into memory as
required. If editing pixels, to avoid losing changes, if a page has been
edited and the next page is then loaded, the “dirty” page will be written
to a tmp file. This class’s getters will then retrieve data from the tmp
file if that data is requested from the “dirty” page. Note that “dirty”
pages are written to tmp files as floats, but stored in memory as double.
This means data is truncated when moving pages, hence pixel data should not
be relied upon being accurate to double precision.</p>
</div></blockquote>
<p>Usage:</p>
<blockquote>
<div><blockquote>
<div><p>&gt;&gt; pix_data = PixelData(data)
&gt;&gt; signal = pix_data.signal;</p>
</div></blockquote>
<p>or equivalently:</p>
<blockquote>
<div><p>&gt;&gt; pix_data = PixelData();
&gt;&gt; pix_data.data = data;
&gt;&gt; signal = pix_data.get_data(‘signal’);</p>
</div></blockquote>
<p>To retrieve multiple fields of data, e.g. run_idx and energy_idx, for pixels 1 to 10:</p>
<blockquote>
<div><p>&gt;&gt; pix_data = PixelData(data);
&gt;&gt; signal = pix_data.get_data({‘run_idx’, ‘energy_idx’}, 1:10);</p>
</div></blockquote>
<p>To retrieve data for pixels 1, 4 and 10 (returning another PixelData object):</p>
<blockquote>
<div><p>&gt;&gt; pix_data = PixelData(data);
&gt;&gt; pixel_subset = pix_data.get_pixels([1, 4, 10])</p>
</div></blockquote>
<p>To sum the signal of a file-backed object where the page size is less than
amount of data in the file:</p>
<blockquote>
<div><p>&gt;&gt; pix = PixelData(‘my_data.sqw’)
&gt;&gt; signal_sum = 0;
&gt;&gt; while pix.has_more()
&gt;&gt;     signal_sum = signal_sum + pix.signal;
&gt;&gt;     pix.advance();
&gt;&gt; end</p>
</div></blockquote>
</div></blockquote>
<dl>
<dt>Properties:</dt><dd><dl class="simple">
<dt>u1, u2, u3     - The 1st, 2nd and 3rd dimensions of the Crystal</dt><dd><p>Cartesian coordinates in projection axes, units are per Angstrom (1 x n arrays)</p>
</dd>
</dl>
<p>dE             - The energy transfer value for each pixel in meV (1 x n array)
coordinates    - The coords in projection axes of the pixel data [u1, u2, u3, dE] (4 x n array)
q_coordinates  - The spacial coords in projection axes of the pixel data [u1, u2, u3] (3 x n array)
run_idx        - The run index the pixel originated from (1 x n array)
detector_idx   - The detector group number in the detector listing for the pixels (1 x n array)
energy_idx     - The energy bin numbers (1 x n array)
signal         - The signal array (1 x n array).
variance       - The variance on the signal array (variance i.e. error bar squared) (1 x n array)</p>
<p>num_pixels     - The number of pixels in the data block.
pix_range      - [2x4] array of the range of pixels coordinates in Crystal Cartesian coordinate system.</p>
<dl class="simple">
<dt>data           - The raw pixel data - usage of this attribute is discouraged, the structure</dt><dd><p>of the return value is not guaranteed.</p>
</dd>
</dl>
<p>page_size      - The number of pixels in the currently loaded page.</p>
</dd>
</dl>
<dl class="mat attribute">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.PixelData.DATA_POINT_SIZE">
<span class="sig-name descname"><span class="pre">DATA_POINT_SIZE</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'8'</span></em><a class="headerlink" href="#sqw.PixelData.@PixelData.PixelData.DATA_POINT_SIZE" title="Permalink to this definition"></a></dt>
<dd><p>num bytes in a double</p>
</dd></dl>

<dl class="mat attribute">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.PixelData.DEFAULT_PAGE_SIZE">
<span class="sig-name descname"><span class="pre">DEFAULT_PAGE_SIZE</span></span><em class="property"> <span class="pre">=</span> <span class="pre">'realmax'</span></em><a class="headerlink" href="#sqw.PixelData.@PixelData.PixelData.DEFAULT_PAGE_SIZE" title="Permalink to this definition"></a></dt>
<dd><p>this gives no paging by default</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.PixelData.PixelData">
<span class="sig-name descname"><span class="pre">PixelData</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">arg</span></em>, <em class="sig-param"><span class="pre">mem_alloc</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.PixelData.PixelData" title="Permalink to this definition"></a></dt>
<dd><p>Construct a PixelData object from the given data. Default
construction initialises the underlying data as an empty (9 x 0)
array.</p>
<blockquote>
<div><p>&gt;&gt; obj = PixelData(ones(9, 200))</p>
<p>&gt;&gt; obj = PixelData(200)  % initialise 200 pixels with underlying data set to zero</p>
<p>&gt;&gt; obj = PixelData(file_path)  % initialise pixel data from an sqw file</p>
<p>&gt;&gt; obj = PixelData(faccess_reader)  % initialise pixel data from an sqw file reader</p>
<p>&gt;&gt; obj = PixelData(faccess_reader, mem_alloc)  % set maximum memory allocation</p>
</div></blockquote>
<blockquote>
<div><blockquote>
<div><dl class="simple">
<dt>arg    A 9 x n matrix, where each row corresponds to a pixel and</dt><dd><dl class="simple">
<dt>the columns correspond to the following:</dt><dd><p>col 1: u1
col 2: u2
col 3: u3
col 4: dE
col 5: run_idx
col 6: detector_idx
col 7: energy_idx
col 8: signal
col 9: variance</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>arg    An integer specifying the desired number of pixels. The underlying</dt><dd><p>data will be filled with zeros.</p>
</dd>
</dl>
<p>arg    A path to an SQW file.</p>
<p>arg    An instance of an sqw_binfile_common file reader.</p>
<dl class="simple">
<dt>mem_alloc    The maximum amount of memory allocated to hold pixel</dt><dd><p>data in bytes. If pixels cannot all be held in memory
at one time, they will be loaded from the file
(specified by ‘arg’) when they are required. This
argument does nothing if the class is constructed with
in-memory data. (Optional)</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.PixelData.advance">
<span class="sig-name descname"><span class="pre">advance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.PixelData.advance" title="Permalink to this definition"></a></dt>
<dd><p>Load the next page of pixel data from the file backing the object</p>
<p>This function will throw a PIXELDATA:advance error if attempting to
advance past the final page of data in the file.</p>
<p>This function does nothing if the pixel data is not file-backed.</p>
<blockquote>
<div><p>&gt;&gt; obj.advance()
&gt;&gt; obj.advance(‘nosave’, true)</p>
</div></blockquote>
<dl class="simple">
<dt>nosave  Keyword argument. Set to true to discard changes to cache.</dt><dd><p>(default: false)</p>
</dd>
</dl>
<p>current_page_number  The new page and total number of pages advance will
walk through to complete the algorithm</p>
</dd></dl>

<dl class="mat staticmethod">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.PixelData.cat">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">cat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.PixelData.cat" title="Permalink to this definition"></a></dt>
<dd><p>Concatenate the given PixelData objects’ pixels. This function performs
a straight-forward data concatenation.</p>
<blockquote>
<div><p>&gt;&gt; joined_pix = PixelData.cat(pix_data1, pix_data2);</p>
</div></blockquote>
<blockquote>
<div><p>varargin    A cell array of PixelData objects</p>
</div></blockquote>
<blockquote>
<div><dl class="simple">
<dt>obj         A PixelData object containing all the pixels in the inputted</dt><dd><p>PixelData objects</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.PixelData.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.PixelData.copy" title="Permalink to this definition"></a></dt>
<dd><p>Make an independent copy of this object
This method simply constructs a new PixelData instance by calling
the constructor with the input object as an argument. Because of
this, any properties that need to be explicitly copied must be
copied within this classes “copy-constructor”.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.PixelData.delete">
<span class="sig-name descname"><span class="pre">delete</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.PixelData.delete" title="Permalink to this definition"></a></dt>
<dd><p>Class destructor to delete any temporary files</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.PixelData.has_more">
<span class="sig-name descname"><span class="pre">has_more</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.PixelData.has_more" title="Permalink to this definition"></a></dt>
<dd><p>Returns true if there are subsequent pixels stored in the file that
are not held in the current page</p>
<blockquote>
<div><p>&gt;&gt; has_more = pix.has_more();</p>
</div></blockquote>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.PixelData.is_filebacked">
<span class="sig-name descname"><span class="pre">is_filebacked</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.PixelData.is_filebacked" title="Permalink to this definition"></a></dt>
<dd><p>Return true if the pixel data is backed by a file or files. Returns
false if all pixel data is held in memory</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.PixelData.isempty">
<span class="sig-name descname"><span class="pre">isempty</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.PixelData.isempty" title="Permalink to this definition"></a></dt>
<dd><p>Return true if the PixelData object holds no pixel data</p>
</dd></dl>

<dl class="mat staticmethod">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.PixelData.loadobj">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">loadobj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">S</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.PixelData.loadobj" title="Permalink to this definition"></a></dt>
<dd><p>Load a PixelData object from a .mat file</p>
<dl>
<dt>&gt;&gt; obj = PixelData.loadobj(S)</dt><dd><blockquote>
<div><dl class="simple">
<dt>S       A data, produeced by saveobj operation and stored</dt><dd><p>in .mat file</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>obj     An instance of PixelData object or array of objects</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.PixelData.move_to_first_page">
<span class="sig-name descname"><span class="pre">move_to_first_page</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.PixelData.move_to_first_page" title="Permalink to this definition"></a></dt>
<dd><p>Reset the object to point to the first page of pixel data in the file
and clear the current cache</p>
<blockquote>
<div><p>This function does nothing if pixels are not file-backed.</p>
</div></blockquote>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.PixelData.set_range">
<span class="sig-name descname"><span class="pre">set_range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">pix_range</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.PixelData.set_range" title="Permalink to this definition"></a></dt>
<dd><p>Function allows to set the pixels range (min/max values of
pixels coordinates)</p>
<p>Use with caution!!! No checks that the set range is the
correct range for pixels, holded by the class are
performed, while subsequent algorithms may rely on pix range
to be correct. A out-of memory write can occur during rebinning
if the range is smaller, then the actual range.</p>
<p>Necessary to set up the pixel range when filebased
pixels are modified by algorithm and correct range
calculations are expensive</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.PixelData.struct">
<span class="sig-name descname"><span class="pre">struct</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.PixelData.struct" title="Permalink to this definition"></a></dt>
<dd><p>convert object into saveable and serializable structure</p>
</dd></dl>

</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.append">
<span class="sig-prename descclassname"><span class="pre">sqw.PixelData.&#64;PixelData.</span></span><span class="sig-name descname"><span class="pre">append</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">obj</span></em>, <em class="sig-param"><span class="pre">pix</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.append" title="Permalink to this definition"></a></dt>
<dd><p>Join the pixels in the given PixelData object to the end of this
object.</p>
<p>The pixels to append must all be in memory and you cannot append pixels if
the inputted PixelData object has more pixels than are allowed in a single
page.</p>
<p>pix    A PixelData object containing the pixels to append</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.compute_bin_data">
<span class="sig-prename descclassname"><span class="pre">sqw.PixelData.&#64;PixelData.</span></span><span class="sig-name descname"><span class="pre">compute_bin_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">obj</span></em>, <em class="sig-param"><span class="pre">npix</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.compute_bin_data" title="Permalink to this definition"></a></dt>
<dd><p>Compute the mean signal and variance given the number of contributing
pixels for each bin
Returns empty arrays if obj contains no pixels.</p>
<blockquote>
<div><p>&gt;&gt; [mean_signal, mean_variance] = compute_bin_data(obj, npix)</p>
</div></blockquote>
<p>npix   The number of contributing pixels to each bin of the plot axes</p>
<dl class="simple">
<dt>mean_signal     The average signal for each plot axis bin.</dt><dd><p>size(mean_signal) = size(npix)</p>
</dd>
<dt>mean_variance   The average variance for each plot axis bin.</dt><dd><p>size(mean_variance) = size(npix)</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.do_binary_op">
<span class="sig-prename descclassname"><span class="pre">sqw.PixelData.&#64;PixelData.</span></span><span class="sig-name descname"><span class="pre">do_binary_op</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">obj</span></em>, <em class="sig-param"><span class="pre">operand</span></em>, <em class="sig-param"><span class="pre">binary_op</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.do_binary_op" title="Permalink to this definition"></a></dt>
<dd><dl>
<dt>DO_BINARY_OP perform a binary operation between this object and the given</dt><dd><p>operand</p>
<p>&gt;&gt; pix_diff = obj.do_binary_op(other_pix, &#64;minus_single, ‘flip’, true)</p>
<p>&gt;&gt; pix_sum = obj.do_binary_op(signal_array, &#64;plus_single, ‘npix’, npix)</p>
<p>&gt;&gt; pix_sum = obj.do_binary_op(signal_array, &#64;plus_single, ‘npix’, npix, ‘flip’, true)</p>
</dd>
</dl>
<dl class="simple">
<dt>operand    The second operand to use in the binary operation.</dt><dd><dl class="simple">
<dt>The operand must have one of the following types:</dt><dd><ul class="simple">
<li><p>scalar double</p></li>
<li><p>double array, the size of the array must be equal to
obj.num_pixels</p></li>
<li><p>object with fields ‘s’ and ‘e’ (e.g. dnd or sigvar)</p></li>
<li><p>another PixelData object with obj.num_pixels equal</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>binary_op  Function handle pointing to the desired binary operation. The</dt><dd><p>function should take 2 objects with ‘.s’ and ‘.e’ attributes, e.g.
a sigvar object</p>
</dd>
</dl>
<dl class="simple">
<dt>flip       Flip the order of the operands, e.g. perform “this - operand” if</dt><dd><p>flip is false, perform “operand - this” if flip is true.</p>
</dd>
<dt>npix       An array giving number of pixels in each bin. This argument should</dt><dd><p>have equal size to operand (assuming operand is numeric) and
sum(npix, [], ‘all’) must be equal to obj.num_pixels</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.do_unary_op">
<span class="sig-prename descclassname"><span class="pre">sqw.PixelData.&#64;PixelData.</span></span><span class="sig-name descname"><span class="pre">do_unary_op</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">obj</span></em>, <em class="sig-param"><span class="pre">unary_op</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.do_unary_op" title="Permalink to this definition"></a></dt>
<dd><p>Perform a unary operation on this object’s signal and variance arrays</p>
<dl class="simple">
<dt>unary_op   Function handle pointing to the operation to perform. This</dt><dd><p>operation should take a sigvar object as an argument.</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.equal_to_tol">
<span class="sig-prename descclassname"><span class="pre">sqw.PixelData.&#64;PixelData.</span></span><span class="sig-name descname"><span class="pre">equal_to_tol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">obj</span></em>, <em class="sig-param"><span class="pre">other_pix</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.equal_to_tol" title="Permalink to this definition"></a></dt>
<dd><p>EQUAL_TO_TOL Check if two PixelData objects are equal to a given tolerance</p>
<p>pix        The first pixel data object to compare.</p>
<p>other_pix  The second pixel data object to compare.</p>
<dl>
<dt>tol        Tolerance criterion for numeric arrays</dt><dd><p>(default = [0, 0] i.e. equality)
It has the form: [abs_tol, rel_tol] where</p>
<blockquote>
<div><p>abs_tol     absolute tolerance (&gt;=0; if =0 equality required)
rel_tol     relative tolerance (&gt;=0; if =0 equality required)</p>
</div></blockquote>
<p>If either criterion is satisfied then equality within tolerance
is accepted.</p>
<blockquote>
<div><dl class="simple">
<dt>Examples:</dt><dd><p>[1e-4, 1e-6]    absolute 1e-4 or relative 1e-6 required
[1e-4, 0]       absolute 1e-4 required
[0, 1e-6]       relative 1e-6 required
[0, 0]          equality required
0               equivalent to [0,0]</p>
</dd>
</dl>
</div></blockquote>
<p>A scalar tolerance can be given where the sign determines if
the tolerance is absolute or relative:</p>
<blockquote>
<div><p>+ve : absolute tolerance  abserr = abs(a-b)
-ve : relative tolerance  relerr = abs(a-b)/max(abs(a),abs(b))</p>
</div></blockquote>
<dl class="simple">
<dt>Examples:</dt><dd><p>1e-4            absolute tolerance, equivalent to [1e-4, 0]
-1e-6           relative tolerance, equivalent to [0, 1e-6]</p>
</dd>
</dl>
</dd>
</dl>
<p>nan_equal  Treat NaNs as equal (true or false; default=true).</p>
<dl class="simple">
<dt>name_a     Explicit name of variable a for use in messages</dt><dd><p>Usually not required, as the name of a variable will
be discovered. However, if the input argument is an array
element e.g. my_variable{3}  then the name is not
discoverable in Matlab, and default ‘input_1’ will be
used unless a different value is given with the keyword ‘name_a’.
(default = ‘input_1’).</p>
</dd>
<dt>name_b     Explicit name of variable b for use in messages.</dt><dd><p>The same comments apply as for ‘name_a’ except the default is
‘input_2’.
(default = ‘input_2’).</p>
</dd>
</dl>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.get_data">
<span class="sig-prename descclassname"><span class="pre">sqw.PixelData.&#64;PixelData.</span></span><span class="sig-name descname"><span class="pre">get_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">obj</span></em>, <em class="sig-param"><span class="pre">pix_fields</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.get_data" title="Permalink to this definition"></a></dt>
<dd><p>GET_DATA Retrieve data for a field, or fields, for the given pixel indices in
the full pixel block. If no pixel indices are given, the full range of pixels
is returned.</p>
<p>This method provides a convenient way of retrieving multiple fields
of data from the pixel block. When retrieving multiple fields, the
columns of data will be ordered corresponding to the order the fields
appear in the inputted cell array.</p>
<blockquote>
<div><dl class="simple">
<dt>&gt;&gt; sig_and_err = pix.get_data({‘signal’, ‘variance’})</dt><dd><p>retrieves the signal and variance over the whole range of pixels</p>
</dd>
<dt>&gt;&gt; run_det_id_range = pix.get_data({‘run_idx’, ‘detector_idx’}, 15640:19244);</dt><dd><p>retrieves the run and detector IDs for pixels 15640 to 19244</p>
</dd>
</dl>
</div></blockquote>
<blockquote>
<div><p>pix_fields       The name of a field, or a cell array of field names
abs_pix_indices  The pixel indices to retrieve, if not given, get full range.</p>
<blockquote>
<div><p>The syntax for these indices attempts to replicate indexing
into a regular Matlab array. You can use logical indices
as well as normal indices, and you can index into the array
“out-of-order”. However, you cannot use <cite>end</cite>, but it is
possible to achieve the same effect using the <cite>num_pixels</cite>
property.</p>
</div></blockquote>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.get_pix_in_ranges">
<span class="sig-prename descclassname"><span class="pre">sqw.PixelData.&#64;PixelData.</span></span><span class="sig-name descname"><span class="pre">get_pix_in_ranges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">obj</span></em>, <em class="sig-param"><span class="pre">abs_indices_starts</span></em>, <em class="sig-param"><span class="pre">abs_indices_ends</span></em>, <em class="sig-param"><span class="pre">recalculate_pix_range</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.get_pix_in_ranges" title="Permalink to this definition"></a></dt>
<dd><p>GET_PIX_IN_RANGES read pixels in the specified ranges
Ranges are inclusive.</p>
<blockquote>
<div><p>&gt;&gt; pix = get_pix_in_ranges([1, 12, 25], [6, 12, 27])</p>
</div></blockquote>
<p>pix_starts  Absolute indices of the starts of pixel ranges [Nx1 or 1xN array].
pix_ends    Absolute indices of the ends of pixel ranges [Nx1 or 1xN array].</p>
<p>pix_out     A PixelData object containing the pixels in the given ranges.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.get_pixels">
<span class="sig-prename descclassname"><span class="pre">sqw.PixelData.&#64;PixelData.</span></span><span class="sig-name descname"><span class="pre">get_pixels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">obj</span></em>, <em class="sig-param"><span class="pre">abs_pix_indices</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.get_pixels" title="Permalink to this definition"></a></dt>
<dd><p>Retrieve the pixels at the given indices in the full pixel block,
return a new PixelData object.</p>
<blockquote>
<div><p>&gt;&gt; pix_out = pix.get_pixels(15640:19244)  % retrieve pixels at indices 15640 to 19244</p>
<p>&gt;&gt; pix_out = pix.get_pixels([1, 0, 1])  % retrieve pixels at indices 1 and 3</p>
</div></blockquote>
<p>The function attempts to mimic the behaviour you would see when indexing into
a Matlab array. The difference being the returned object is a PixelData
object and not an array.</p>
<p>This function may be useful if you want to extract data for a particular
image bin.</p>
<blockquote>
<div><blockquote>
<div><dl class="simple">
<dt>abs_pix_indices  A vector of positive integers or a vector of logicals.</dt><dd><p>The syntax for these indices attempts to replicate indexing
into a regular Matlab array. You can use logical indices
as well as normal indices, and you can index into the array
“out-of-order”. However, you cannot use <cite>end</cite>, but it is
possible to achieve the same effect using the <cite>num_pixels</cite>
property.</p>
</dd>
</dl>
</div></blockquote>
<p>Optional:
‘-ignore_range’  – if provided, new pix_object will not contain correct</p>
<blockquote>
<div><p>pixel ranges</p>
</div></blockquote>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.mask">
<span class="sig-prename descclassname"><span class="pre">sqw.PixelData.&#64;PixelData.</span></span><span class="sig-name descname"><span class="pre">mask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">obj</span></em>, <em class="sig-param"><span class="pre">mask_array</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.mask" title="Permalink to this definition"></a></dt>
<dd><p>MASK remove the pixels specified by the input logical array</p>
<p>You must specify exactly one return argument when calling this function.</p>
<dl>
<dt>mask_array   A logical array specifying which pixels should be kept/removed</dt><dd><p>from the PixelData object. Must be of length equal to the number
of pixels in ‘obj’ or equal in size to the ‘npix’ argument. A
true/1 in the array indicates that the pixel at that index
should be retained, a false/0 indicates the pixel should be
removed.</p>
</dd>
<dt>npix         (Optional)</dt><dd><p>Array of integers that specify how many times each value in
mask_array should be replicated. This is useful for when masking
all pixels contributing to a bin. Size must be equal to that of
‘mask_array’. E.g.:</p>
<blockquote>
<div><p>mask_array = [      0,     1,     1,  0,     1]
npix       = [      3,     2,     2,  1,     2]
full_mask  = [0, 0, 0,  1, 1,  1, 1,  0,  1, 1]</p>
</div></blockquote>
<p>The npix array must account for all pixels in the PixelData
object i.e. sum(npix, ‘all’) == obj.num_pixels. It must also be
the same dimensions as ‘mask_array’ i.e.
all(size(mask_array) == size(npix)).</p>
</dd>
</dl>
<p>pix_out      A PixelData object containing only non-masked pixels.</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.move_to_page">
<span class="sig-prename descclassname"><span class="pre">sqw.PixelData.&#64;PixelData.</span></span><span class="sig-name descname"><span class="pre">move_to_page</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">obj</span></em>, <em class="sig-param"><span class="pre">page_number</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.move_to_page" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>Set the object to point at the given page number</dt><dd><p>This function does nothing if the object is not file-backed or is
already on the given page</p>
</dd>
</dl>
<p>Inputs:
page_number – page number to move to</p>
<p>Returns:
page_number – the page this routine moved to
total_num_pages – total number of pages, present in the file</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.noisify">
<span class="sig-prename descclassname"><span class="pre">sqw.PixelData.&#64;PixelData.</span></span><span class="sig-name descname"><span class="pre">noisify</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">obj</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.noisify" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>This is a method of the PixelData class.
It is called from the noisify(sqw_object,[options]) function to allow
the noisify functionality to be applied on a per-page basis to the
sqw object’s pixel data.
See noisify(sqw_object,…) for details of the input and the
Herbert noisify function for details of how the input is used.
This noisify adds random noise to the object’s signal array, and a fixed
error bar to the variance array, paging as required. The options in
varargin specify how that is done; see the above functions for details.
For options where the signal absolute maximum is used in the noise
scaling, a paged pre-scan of the signal provides the maximum over all
pages.</p>
<p>obj         The PixelData instance.
varargs     Options for random number distribution and noise magnitude</p>
<blockquote>
<div><p>scaling.</p>
</div></blockquote>
<dl class="simple">
<dt>pix_out     If specified, returns a “noisified” copy of the input data</dt><dd><p>Otherwise it is a reference to the input object, which is
“noisified” in place.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.recalc_pix_range">
<span class="sig-prename descclassname"><span class="pre">sqw.PixelData.&#64;PixelData.</span></span><span class="sig-name descname"><span class="pre">recalc_pix_range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">obj</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.recalc_pix_range" title="Permalink to this definition"></a></dt>
<dd><p>Recalculate pixels range in the situations, where the
range for some reason appeared to be missing (i.e. loading pixels from
old style files) or changed through private interface (for efficiency)
and the internal integrity of the object has been violated.</p>
<p>returns obj for compatibility with recalc_pix_range method of
combine_pixel_info class, which may be used instead of PixelData
for the same purpose.
recalc_pix_range is a normal Matlab value object (not a handle object),
returning its changes in LHS</p>
</dd></dl>

<dl class="mat function">
<dt class="sig sig-object mat" id="sqw.PixelData.&#64;PixelData.set_data">
<span class="sig-prename descclassname"><span class="pre">sqw.PixelData.&#64;PixelData.</span></span><span class="sig-name descname"><span class="pre">set_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">obj</span></em>, <em class="sig-param"><span class="pre">pix_fields</span></em>, <em class="sig-param"><span class="pre">data</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sqw.PixelData.@PixelData.set_data" title="Permalink to this definition"></a></dt>
<dd><p>SET_PIXELS Update the data on the given pixel data fields</p>
<p>The number of columns in ‘data’ must be equal to the number of fields in
‘pix_fields’. The number of rows in ‘data’ must be equal to the number of
elements in ‘abs_pix_indices’.</p>
<dl class="simple">
<dt>Set the first 100 pixels’ signal and variance to zero</dt><dd><p>&gt;&gt; set_data({‘signal’, ‘variance’}, zeros(2, 100), 1:100);</p>
</dd>
</dl>
<p>pix_fields       The name of a field, or a cell array of field names.
data             The data with which to set the given fields.
abs_pix_indices  The indices to set data on. If not specified all indices are</p>
<blockquote>
<div><p>updated and ‘size(data, 2)’ must equal to obj.num_pixels.</p>
</div></blockquote>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="developers/Developer_info.html" class="btn btn-neutral float-left" title="Developer info" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="General_disclaimer.html" class="btn btn-neutral float-right" title="General disclaimer" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2006-2021, STFC RAL.
      <span class="lastupdated">Last updated on Feb 7, 2022, 1:41:42 PM.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>