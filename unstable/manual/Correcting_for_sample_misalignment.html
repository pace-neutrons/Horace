

<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>4. Correcting for sample misalignment &mdash; Horace  documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js?v=b3ba4146"></script>
      <script src="../_static/doctools.js?v=888ff710"></script>
      <script src="../_static/sphinx_highlight.js?v=4825356b"></script>
      <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="5. Cutting data of interest from SQW files and objects" href="Cutting_data_of_interest_from_SQW_files_and_objects.html" />
    <link rel="prev" title="3. Data diagnostics" href="Data_diagnostics.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Horace
              <img src="../_static/150px-Quintus_Horatius_Flaccus.jpg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../Introduction.html">Introduction and Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../User_guide.html">User’s Guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../Horace_manual.html">Horace Manual</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Planning_a_Horace_scan.html">1. Planning a Horace scan</a></li>
<li class="toctree-l2"><a class="reference internal" href="Generating_SQW_files.html">2. Generating SQW files</a></li>
<li class="toctree-l2"><a class="reference internal" href="Data_diagnostics.html">3. Data diagnostics</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">4. Correcting for sample misalignment</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#step-1-determining-the-true-bragg-peak-positions">4.1. Step 1 - determining the true Bragg peak positions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#bragg-positions">4.1.1. Bragg Positions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#check-the-bragg-positions-fits-worked-properly">4.1.2. Check the Bragg positions fits worked properly</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#step-2-calculate-the-misalignment-correction">4.2. Step 2 - calculate the misalignment correction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#step-3-apply-the-correction-to-the-data">4.3. Step 3 - apply the correction to the data</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#option-1-apply-the-correction-to-an-existing-sqw-file-or-object">4.3.1. Option 1 : apply the correction to an existing sqw file or object</a></li>
<li class="toctree-l4"><a class="reference internal" href="#option-2-calculate-goniometer-offsets-for-regeneration-of-sqw-file-s">4.3.2. Option 2 : calculate goniometer offsets for regeneration of sqw file(s)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#option-2a-calculate-the-true-u-and-v-for-your-misaligned-crystal">4.3.3. Option 2a : calculate the true u and v for your misaligned crystal</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#list-of-alignment-correction-routines">4.4. List of alignment correction routines</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id1">4.4.1. bragg_positions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bragg-positions-view">4.4.2. bragg_positions_view</a></li>
<li class="toctree-l4"><a class="reference internal" href="#crystal-pars-correct">4.4.3. crystal_pars_correct</a></li>
<li class="toctree-l4"><a class="reference internal" href="#refine-crystal">4.4.4. refine_crystal</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ubmatrix">4.4.5. ubmatrix</a></li>
<li class="toctree-l4"><a class="reference internal" href="#uv-correct">4.4.6. uv_correct</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rlu-corr-to-lattice">4.4.7. rlu_corr_to_lattice</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Cutting_data_of_interest_from_SQW_files_and_objects.html">5. Cutting data of interest from SQW files and objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="Special_sqw_information.html">6. Special <code class="docutils literal notranslate"><span class="pre">SQW</span></code> information from sqw objects and files</a></li>
<li class="toctree-l2"><a class="reference internal" href="Save_and_load.html">7. Loading <code class="docutils literal notranslate"><span class="pre">sqw</span></code> and <code class="docutils literal notranslate"><span class="pre">dnd</span></code> objects to memory</a></li>
<li class="toctree-l2"><a class="reference internal" href="Save_and_load.html#saving-sqw-objects-from-memory-and-creating-filebacked-objects">8. Saving sqw objects from memory and creating filebacked objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reshaping_etc.html">9. Other shape functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="Symmetrising_etc.html">10. Symmetry Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="Unary_operations.html">11. Unary operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="Binary_operations.html">12. Binary operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="Plotting.html">13. Plotting</a></li>
<li class="toctree-l2"><a class="reference internal" href="Simulation.html">14. Simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Multifit.html">15. Multifit</a></li>
<li class="toctree-l2"><a class="reference internal" href="Tobyfit.html">16. Tobyfit</a></li>
<li class="toctree-l2"><a class="reference internal" href="Parallel.html">17. Running Horace in Parallel</a></li>
<li class="toctree-l2"><a class="reference internal" href="Changing_Horace_settings.html">18. Changing Horace settings</a></li>
<li class="toctree-l2"><a class="reference internal" href="List_of_functions.html">List of functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="Input_file_formats.html">Input file formats</a></li>
<li class="toctree-l2"><a class="reference internal" href="FAQ.html">FAQ</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Example_scripts.html">Example Scripts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Citing.html">Citing Horace</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Developers.html">For Developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Contributing.html">Contributing to Horace</a></li>
<li class="toctree-l1"><a class="reference internal" href="../General_disclaimer.html">General disclaimer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Previous_versions.html">Previous Versions</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Horace</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../Horace_manual.html">Horace Manual</a></li>
      <li class="breadcrumb-item active"><span class="section-number">4. </span>Correcting for sample misalignment</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/manual/Correcting_for_sample_misalignment.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="correcting-for-sample-misalignment">
<h1><span class="section-number">4. </span>Correcting for sample misalignment<a class="headerlink" href="#correcting-for-sample-misalignment" title="Permalink to this heading"></a></h1>
<p>When mounting your sample on a spectrometer, it can often be the case that it is slightly misaligned with respect to the
‘perfect’ alignment assumed when generating the SQW file (the direction of <code class="docutils literal notranslate"><span class="pre">u</span></code> and <code class="docutils literal notranslate"><span class="pre">v</span></code> vectors provided in <code class="docutils literal notranslate"><span class="pre">gen_sqw</span></code> and
<code class="docutils literal notranslate"><span class="pre">accumulate_sqw</span></code>, where <code class="docutils literal notranslate"><span class="pre">u</span></code> is parallel to the beam and <code class="docutils literal notranslate"><span class="pre">v</span></code> defines the sample rotation plain).
It is straightforward to correct this misalignment, once enough data have been accumulated, by
comparing the positions of Bragg peaks with what they are expected to be.</p>
<p id="core-alignment">Alignment correction is based on a three-step process:</p>
<ol class="arabic simple">
<li><p>First, the misalignment must be determined from known theoretical diffraction patterns expected from the crystal and
actual diffraction patterns measured in the experiment.</p></li>
<li><p>Second, the corrections, which would bring actual diffraction patterns as close as possible to the actual patterns
should be identified.</p></li>
<li><p>Then, the correction must be applied to the data.</p></li>
</ol>
<p>In practice, these steps usually applied iteratively. Namely:</p>
<ol class="upperalpha simple" id="stepa">
<li><p>Evaluate actual diffraction pattern taking number of cuts and slices in different directions. The directions should cover
whole 3D Q-space. Select actual diffraction patterns which demonstrate misalignment best and are least affected by experimental
inefficiencies (e.g. edges of detectors covered areas, twinning reflections, can reflections etc…)</p></li>
</ol>
<ol class="upperalpha simple" id="stepb" start="2">
<li><p>Perform <a class="reference internal" href="#core-alignment"><span class="std std-ref">three-step process</span></a> above using actual diffraction patterns, identified at <a class="reference internal" href="#stepa"><span class="std std-ref">Step A</span></a>.</p></li>
</ol>
<ol class="upperalpha simple" id="stepc" start="3">
<li><p>Evaluate result of alignment observing modified diffraction patterns.</p></li>
</ol>
<ol class="upperalpha simple" id="stepd" start="4">
<li><p>Revert alignment corrections and go to <a class="reference internal" href="#stepa"><span class="std std-ref">Step A</span></a> with modified actual diffraction patterns. Finish when sure that selected
representative diffraction patters and resulting alignment looks correct and not affected by selecting slightly
different set of representative diffraction patters.</p></li>
</ol>
<p>Let’s consider all these steps in more details.</p>
<section id="step-1-determining-the-true-bragg-peak-positions">
<h2><span class="section-number">4.1. </span>Step 1 - determining the true Bragg peak positions<a class="headerlink" href="#step-1-determining-the-true-bragg-peak-positions" title="Permalink to this heading"></a></h2>
<section id="bragg-positions">
<h3><span class="section-number">4.1.1. </span>Bragg Positions<a class="headerlink" href="#bragg-positions" title="Permalink to this heading"></a></h3>
<p>First you should identify several Bragg peaks which are strong and not parallel along <span class="math notranslate nohighlight">\(\{p \in{} P:
\Gamma{}\rightarrow{}p\}\)</span> in your data, where <span class="math notranslate nohighlight">\(\{P\}\)</span> is the set of Bragg peaks, where
<span class="math notranslate nohighlight">\(\Gamma{}\rightarrow{}p\)</span> is the path from the gamma point (<span class="math notranslate nohighlight">\([0,0,0]\)</span>) to the point <span class="math notranslate nohighlight">\(p\)</span>.</p>
<p>Henceforth, we define <span class="math notranslate nohighlight">\(\{\vec{Q}\}\)</span> as the set of vectors from the gamma point to each Bragg point <span class="math notranslate nohighlight">\(\{p
\in{} P: \vec{\Gamma{}p}\}\)</span>.</p>
<p>From the accuracy point of view it is also reasonable not to have them all on one plane which means that more then 3 Bragg peaks
should be used.</p>
<p>The following routine generates radial and transverse cuts around specified Bragg peaks and calculates the deviation
from the expected values.</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">rlu_actual</span><span class="p">,</span><span class="w"> </span><span class="n">widths</span><span class="p">,</span><span class="w"> </span><span class="n">wcut</span><span class="p">,</span><span class="w"> </span><span class="n">wpeak</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">bragg_positions</span><span class="w"> </span><span class="p">(</span><span class="n">sqw_obj</span><span class="p">,</span><span class="w"> </span><span class="n">bragg_expected</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">                </span><span class="n">radial_cut_length</span><span class="p">,</span><span class="w"> </span><span class="n">radial_bin_width</span><span class="p">,</span><span class="w"> </span><span class="n">radial_thickness</span><span class="p">,</span><span class="k">...</span>
<span class="w">                </span><span class="n">trans_cut_length</span><span class="p">,</span><span class="w"> </span><span class="n">trans_bin_width</span><span class="p">,</span><span class="w"> </span><span class="n">trans_thickness</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">                </span><span class="n">energy_window</span><span class="p">,</span><span class="w"> </span><span class="o">&lt;</span><span class="n">keyword</span><span class="w"> </span><span class="n">options</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<p>The inputs are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sqw_obj</span></code> - <code class="docutils literal notranslate"><span class="pre">sqw</span></code> object with misaligned data</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bragg_expected</span></code>   - an n-by-3 array specifying the Bragg positions expected from aligned crystal.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">radial_cut_length</span></code> - lengths of the various cuts along each <span class="math notranslate nohighlight">\(\vec{Q}\)</span>-direction
in the Bragg peaks set <span class="math notranslate nohighlight">\(\{P\}\)</span> above.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">radial_bin_width</span></code> - bin (step) sizes along the radial cuts.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">radial_thickness</span></code> - integration thickness along the axes perpendicular to the radial cut direction.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">trans_cut_length</span></code> - lengths of cuts of each cut perpendicular to <span class="math notranslate nohighlight">\(\{\vec{Q}\}\)</span>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">trans_bin_width</span></code> - bin (step) sizes along the transverse cuts</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">trans_thickness</span></code> - integration thickness along the two perpendicular directions to the transverse cuts</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">energy_window</span></code> - Energy integration window around elastic line (meV). Choose according to the instrument resolution.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Units of the <code class="docutils literal notranslate"><span class="pre">`length</span></code>, <code class="docutils literal notranslate"><span class="pre">width</span></code> and <code class="docutils literal notranslate"><span class="pre">thickness</span></code> above are inverse Angstroms <span class="math notranslate nohighlight">\({Å}^{-1}\)</span> or relative.
See below –<code class="docutils literal notranslate"><span class="pre">bin_absolute</span></code> or <code class="docutils literal notranslate"><span class="pre">bin_relative</span></code> keywords.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">energy_window</span></code> is the full energy window.  A good value for <code class="docutils literal notranslate"><span class="pre">energy_window</span></code> is 2 x full-width half-height,
e.g. for -1meV to +1 meV, set <code class="docutils literal notranslate"><span class="pre">energy_window=2</span></code></p>
</div>
<p>The following keyword options are available:</p>
<p>For binning:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'bin_absolute'</span></code> [Default] - denotes that the radial and transverse cut lengths, bin sizes, and thicknesses are in inverse Angstroms (<span class="math notranslate nohighlight">\({Å}^{-1}\)</span>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'bin_relative'</span></code> - denotes that cut lengths, bin sizes and thicknesses are fractions of each  <span class="math notranslate nohighlight">\(\{\vec{Q}\}\)</span> length (<code class="docutils literal notranslate"><span class="pre">radial_cut_length</span></code>) for radial cuts and degrees for transverse cuts.</p></li>
</ul>
<p>For fitting:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'outer'</span></code> [Default] - determines peak position from centre of peak half-height by finding the peak width moving inwards from
the limits of the data</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Useful if there is known to be a single peak in the data as it is more robust to too finely binned data.</p>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'inner'</span></code> - determines the peak position from centre of peak half height by finding the peak width moving outwards
from peak maximum</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'gaussian'</span></code> - fits a Gaussian on a linear background.</p></li>
</ul>
<p>The outputs are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">rlu_actual</span></code> - the actual peak positions as an n-by-3 matrix in <span class="math notranslate nohighlight">\(h,k,l\)</span> as indexed with respect to the current
lattice parameters.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">widths</span></code> - an n-by-3 array containing the FWHH in Ang^-1 of the peaks along each of the three projection axes</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">wcut</span></code> - an n-by-3 array of cuts, along three orthogonal directions through each Bragg point from which the
peak positions were determined.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>These cuts are <code class="docutils literal notranslate"><span class="pre">IX_dataset_1d</span></code> objects and can be plotted using the plot functions.</p>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">wpeak</span></code> - an n-by-3 array of spectra, that summarise the peak analysis.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>These cuts are <code class="docutils literal notranslate"><span class="pre">IX_dataset_1d</span></code> objects and can be plotted using the plot functions.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">wcut</span></code> and <code class="docutils literal notranslate"><span class="pre">wpeak</span></code> can be passed to <code class="docutils literal notranslate"><span class="pre">bragg_positions_view</span></code> to view the output.</p>
</div>
</section>
<section id="check-the-bragg-positions-fits-worked-properly">
<h3><span class="section-number">4.1.2. </span>Check the Bragg positions fits worked properly<a class="headerlink" href="#check-the-bragg-positions-fits-worked-properly" title="Permalink to this heading"></a></h3>
<p>You can make plots of the cuts and fits of your predicted Bragg peaks to check that the program has correctly fitted
everything, using outputs from <code class="docutils literal notranslate"><span class="pre">bragg_positions</span></code> described above.</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">bragg_positions_view</span><span class="p">(</span><span class="n">wcut</span><span class="p">,</span><span class="n">wpeak</span><span class="p">)</span>
</pre></div>
</div>
<p>You will be prompted in the MATLAB command window as to which plot and fit you wish to view, e.g.:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">Enter</span><span class="w"> </span><span class="s">one</span><span class="w"> </span><span class="s">of</span><span class="w"> </span><span class="s">the</span><span class="w"> </span><span class="s">following:</span>
<span class="w">  </span><span class="o">-</span><span class="w"> </span><span class="n">peak</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">scan</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">g</span><span class="p">.</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="mi">3</span>
<span class="w">  </span><span class="o">-</span><span class="w"> </span><span class="o">&lt;</span><span class="n">CR</span><span class="o">&gt;</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="k">continue</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">present</span><span class="w"> </span><span class="n">peak</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">scan</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
<span class="w">  </span><span class="o">-</span><span class="w"> </span><span class="n">Q</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="nb">quit</span>
</pre></div>
</div>
<p>where N is the total number of peaks (e.g. 9 for 9 Bragg peaks) and (p,n) are current peak and scan numbers (e.g. (1,1) for first peak and scan)</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Press <code class="docutils literal notranslate"><span class="pre">'q'</span></code> to exit this interactive mode.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>It is important to use this function to scrutinise the peaks and the fits because there many parameters that may need
adjusting depending on the degree of misalignment of your crystal: the length, binning and thicknesses of the cuts
you specified in <code class="docutils literal notranslate"><span class="pre">bragg_positions</span></code>, the quality of the cuts (for example the Bragg peaks may be near gaps in the
detectors so the cuts are poorly defined), the Bragg peaks may have strange shapes which can confuse the automatic
fitting, etc.</p>
</div>
</section>
</section>
<section id="step-2-calculate-the-misalignment-correction">
<span id="step-2-misalignment-correction"></span><h2><span class="section-number">4.2. </span>Step 2 - calculate the misalignment correction<a class="headerlink" href="#step-2-calculate-the-misalignment-correction" title="Permalink to this heading"></a></h2>
<p>Using the outputs of <code class="docutils literal notranslate"><span class="pre">bragg_positions</span></code>, you can determine a transformation to go from the original
misaligned frame to the aligned frame.</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">alignment_info</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">refine_crystal</span><span class="p">(</span><span class="n">rlu_actual</span><span class="p">,</span><span class="w"> </span><span class="n">alatt0</span><span class="p">,</span><span class="w"> </span><span class="n">angdeg0</span><span class="p">,</span><span class="w"> </span><span class="n">rlu_expected</span><span class="p">,</span><span class="w"> </span><span class="o">&lt;</span><span class="n">keyword</span><span class="w"> </span><span class="n">options</span><span class="o">&gt;</span><span class="p">);</span>
</pre></div>
</div>
<p>The inputs are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">rlu_actual</span></code>  - the an n-by-3 matrix of actual peak positions as in <span class="math notranslate nohighlight">\(h,k,l\)</span> as indexed with the current lattice parameters</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">alatt0,</span> <span class="pre">angdeg0</span></code> - the lattice parameters and angles used in the original (misaligned) sqw file.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rlu_expected</span></code> - the predicted (integer) Bragg peaks corresponding to <code class="docutils literal notranslate"><span class="pre">bragg_expected</span></code></p></li>
</ul>
<p>The keyword options are:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">fix_lattice</span></code> - Fix all lattice parameters <span class="math notranslate nohighlight">\([a,b,c,\alpha,\beta,\gamma]\)</span>, i.e. only allow crystal orientation
to be refined</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fix_alatt</span></code> - Fix <span class="math notranslate nohighlight">\([a,b,c]\)</span>, but allow lattice angles <span class="math notranslate nohighlight">\([\alpha,\beta,\gamma]\)</span> to be refined together with
the crystal orientation</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fix_angdeg</span></code> - Fix <span class="math notranslate nohighlight">\([\alpha,\beta,\gamma]\)</span>, but allow the lattice parameters <span class="math notranslate nohighlight">\([a,b,c]\)</span> to be refined together with crystal orientation</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fix_alatt_ratio</span></code> Fix the ratio of the lattice parameters as given by the values in the inputs, but allow the
overall scale of the lattice to be refined together with crystal orientation</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fix_orient</span></code> - Fix the crystal orientation i.e. only refine the lattice parameters</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">free_alatt</span></code> - keyword followed by array of 3 of booleans, 1=free, 0=fixed</p>
<p>e.g. <code class="docutils literal notranslate"><span class="pre">'free_alatt',[0,1,0],...</span></code> allows only lattice parameter <span class="math notranslate nohighlight">\(b^{*}\)</span> to vary</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">free_angdeg</span></code> - keyword followed by array of 3 of booleans, 1=free, 0=fixed.</p>
<p>e.g. <code class="docutils literal notranslate"><span class="pre">'free_angdeg',[1,1,0],...</span></code> fixes lattice angle gamma buts allows <span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span> to vary</p>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To achieve finer control of the refinement of the lattice parameters, use <code class="docutils literal notranslate"><span class="pre">free_alatt</span></code> and <code class="docutils literal notranslate"><span class="pre">free_angdeg</span></code></p>
</div>
<p>The output is an <code class="docutils literal notranslate"><span class="pre">crystal_alignment_info</span></code> object which contains all the relevant data for crystal realignment, namely
the rotation matrix which aligns Crystal Cartesian frame into correct position and modified lattice parameters, if
<code class="docutils literal notranslate"><span class="pre">refine_crystal</span></code> modified them.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>You are fitting 3 rotation angles and may be 3 lattice parameters and 3 angular parameters. You need at least 9 variables (dimensions) to fit 9 variables. 3 Bragg peaks
in 3D space would provide you with at least 9 parameters, so this is the minimal number of
inputs for the algorithm to work. In practice, it is better to have more actual Bragg positions to build over-defined system of equations. Algorithm minimizes the difference between actual and theoretical Bragg positions by fitting allowed rotation angles and lattice parameters.</p>
</div>
<p>At this stage it would be useful to store inverse alignment transformation to be able to perform <a class="reference internal" href="#stepd"><span class="std std-ref">step D</span></a> without the need to regenerate
your sqw object from the initial misaligned results of the experiment:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;</span><span class="n">reverse_transf</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">crystal_alignment_info</span><span class="p">(</span><span class="n">alatt0</span><span class="p">,</span><span class="n">angdeg0</span><span class="p">);</span>
<span class="o">&gt;&gt;</span><span class="n">reverse_transf</span><span class="p">.</span><span class="n">rotmat</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">alignment_info</span><span class="p">.</span><span class="n">rotmat</span><span class="o">&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>i.e. create crystal alignment info class with your initial lattice parameters and assign inverse rotation matrix defining rotation
which is opposite to the rotation, necessary for corrections you will be applying to your data on the following step.</p>
</section>
<section id="step-3-apply-the-correction-to-the-data">
<h2><span class="section-number">4.3. </span>Step 3 - apply the correction to the data<a class="headerlink" href="#step-3-apply-the-correction-to-the-data" title="Permalink to this heading"></a></h2>
<p>There are different ways to do this, to be preferred in different circumstances.</p>
<p>1. Initially you want to be sure that you have selected correct Bragg peaks,
that adding new peaks would not improve accuracy of your alignment, and that the resulting alignment is satisfactory.
In other words, you are following <a class="reference internal" href="#stepa"><span class="std std-ref">the iterative process</span></a> above.
You want to get your results quickly and possibly experiment with them, modify them and apply or undo your a quickly.
In this case you apply correctios to existing <code class="docutils literal notranslate"><span class="pre">sqw</span></code> file or <code class="docutils literal notranslate"><span class="pre">sqw</span></code> object loaded in memory.</p>
<p>2. When you are satisfied with the result of alignment you may want to regenerate your <code class="docutils literal notranslate"><span class="pre">sqw</span></code> file after calculating goniometer
offsets, which define actual crystal position. You have to do this step if you want to apply various symmetry
transformations to the whole <code class="docutils literal notranslate"><span class="pre">sqw</span></code> file during generation. Alternatively, you may want to “finalize” alignment corrections
applied initially.</p>
<p>Both ways result in an sqw file; the resulting files are identical from a physical point of view.
Minor differences occurs in the data, stored in an sqw file. These differences do not generally affect the results of operations, performed on the file but may affect the performance of following operations. These differences are explained in more details below.</p>
<section id="option-1-apply-the-correction-to-an-existing-sqw-file-or-object">
<h3><span class="section-number">4.3.1. </span>Option 1 : apply the correction to an existing sqw file or object<a class="headerlink" href="#option-1-apply-the-correction-to-an-existing-sqw-file-or-object" title="Permalink to this heading"></a></h3>
<p>There is a simple and fast routine <code class="docutils literal notranslate"><span class="pre">change_crystal</span></code> to apply the changes to an existing file, without the need to regenerate it from raw data.</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;</span><span class="n">change_crystal</span><span class="p">(</span><span class="n">win</span><span class="p">,</span><span class="w"> </span><span class="n">alignment_info</span><span class="p">);</span>
<span class="n">or</span>
<span class="o">&gt;&gt;</span><span class="n">wout</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">change_crystal</span><span class="p">(</span><span class="n">win</span><span class="p">,</span><span class="w"> </span><span class="n">alignment_info</span><span class="p">);</span>
</pre></div>
</div>
<p>The second form of this routine returns aligned <code class="docutils literal notranslate"><span class="pre">sqw</span></code> object. The object is filebacked if pixels data are too big to be loaded in memory.
The second form is mandatory if you are applying alignment to <code class="docutils literal notranslate"><span class="pre">sqw</span></code> object in memory.</p>
<p>Here <code class="docutils literal notranslate"><span class="pre">win</span></code> is a file containing misaligned <code class="docutils literal notranslate"><span class="pre">sqw</span></code> object or filebacked/memory-based <code class="docutils literal notranslate"><span class="pre">sqw</span></code> object and <code class="docutils literal notranslate"><span class="pre">alignment_info</span></code> was determined on the <a class="reference internal" href="#step-2-misalignment-correction"><span class="std std-ref">Step 2</span></a> described above.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you use second form of <code class="docutils literal notranslate"><span class="pre">change_crystal</span></code>, regardless of <code class="docutils literal notranslate"><span class="pre">sqw</span></code> object being file-backed or memory based, you need to <a class="reference internal" href="Save_and_load.html#save"><span class="std std-ref">save</span></a> your result if you want your changes to be permanent. The changes to memory based and file-backed objects disappear if object gets deleted from memory.</p>
</div>
<p>Majority of Horace users may work with files or objects realigned using <code class="docutils literal notranslate"><span class="pre">change_crystal</span></code> without any noticeable hindrance. When <code class="docutils literal notranslate"><span class="pre">change_crystal</span></code>
is applied to object in memory the resulting object is fully aligned and no other actions is necessary to finish alignment. When <code class="docutils literal notranslate"><span class="pre">change_crystal</span></code> applied to file, you may want to do <a class="reference internal" href="#finalize-alignment"><span class="std std-ref">final alignment step</span></a>, but for majority of practical reasons it is unnecessary.</p>
<p>Advanced users may want to know, that <code class="docutils literal notranslate"><span class="pre">change_crystal</span></code> procedure modifies lattice parameters and adds alignment matrix to the pixels data in file.
Pixels themselves are not modified so the alignment procedure is very fast. Pixels will be aligned whenever they are loaded or manipulated
(e.g. accessing pixel data, cutting, doing unary and binary operations, etc.).
The pixels alignment is combined with other transformations, usually performed during pixels manipulations, so the speed of majority of such operations is not affected.
The actual slow-down in operations with aligned file occurs when some advanced algorithms use pixels range (e.g. <code class="docutils literal notranslate"><span class="pre">mask_pixels</span></code> based on a range).
Pixels range is invalidated when pixels are realigned by <code class="docutils literal notranslate"><span class="pre">change_crystal</span></code>, so such algorithms have to calculate this range first. This may take substantial time.</p>
<p>If you are following <a class="reference internal" href="#stepa"><span class="std std-ref">iterative process</span></a> above, after validating your alignment revert your alignment at <a class="reference internal" href="#stepd"><span class="std std-ref">Step D</span></a> applying:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;</span><span class="n">change_crystal</span><span class="p">(</span><span class="n">win</span><span class="p">,</span><span class="w"> </span><span class="n">reverse_transf</span><span class="p">);</span>
<span class="n">or</span>
<span class="o">&gt;&gt;</span><span class="n">wout</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">change_crystal</span><span class="p">(</span><span class="n">wout</span><span class="p">,</span><span class="w"> </span><span class="n">reverse_transf</span><span class="p">);</span>
</pre></div>
</div>
<p>If you performed multiple alignment and <code class="docutils literal notranslate"><span class="pre">change_crystal</span></code> operations on filebacked object without reverting them, you may recover resulting reverse (or direct) transformation from filebacked object’s pixels alignment matrix:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;</span><span class="n">reverse_transf</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">crystal_alignment_info</span><span class="p">(</span><span class="n">alatt0</span><span class="p">,</span><span class="n">angdeg0</span><span class="p">);</span>
<span class="o">&gt;&gt;</span><span class="n">reverse_transf</span><span class="p">.</span><span class="n">rotmat</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">wout</span><span class="p">.</span><span class="n">pix</span><span class="p">.</span><span class="n">alignment_matr</span><span class="o">&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>This is possible because resulting alignment (and de-alignment) matrix is the result of multiplication of sequence of rotation operations.</p>
<p>There is no possibility to retrieve lost initial lattice parameters <code class="docutils literal notranslate"><span class="pre">alatt0</span></code>; <code class="docutils literal notranslate"><span class="pre">angdeg0</span></code> from any <code class="docutils literal notranslate"><span class="pre">sqw</span></code> object and alignment matrix from memory based aligned <code class="docutils literal notranslate"><span class="pre">sqw</span></code> object.
This is why it is recommended to revert the alignment first each time you want to realign your <code class="docutils literal notranslate"><span class="pre">sqw</span></code> object. It is not the critical recommendation, as you can always rebuild your misaligned <code class="docutils literal notranslate"><span class="pre">sqw</span></code> object from the initial experimental results.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">SQW</span></code> file de-alignment procedure, which works regardless of the previous alignment attempts is performed using the following code.
The procedure works only on filebacked objects, as memory based objects do not have alignment matrix attached to the pixels. If you are
investigating your crystal to find most suitable Bragg peaks, you may want to put this procedure at the beginning of each
<a class="reference internal" href="#core-alignment"><span class="std std-ref">alignment iteration</span></a>.</p>
</div>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="c">% de-align crystal if aligned previously and set lattice to its theoretical value;</span>
<span class="n">rlu_rev_corr</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">crystal_alignment_info</span><span class="p">([</span><span class="n">a_theoretical</span><span class="p">,</span><span class="n">b_theoretical</span><span class="p">,</span><span class="n">c_theoretical</span><span class="p">],[</span><span class="n">alpha_theor</span><span class="p">,</span><span class="n">beta_theor</span><span class="p">,</span><span class="n">gama_theor</span><span class="p">]);</span>
<span class="n">sqw_obj</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">sqw</span><span class="p">(</span><span class="n">sqw_file_name</span><span class="p">,</span><span class="s">&#39;file_backed&#39;</span><span class="p">,</span><span class="nb">true</span><span class="p">);</span><span class="w"> </span><span class="c">% build filebacked object to get access to pixels metadata</span>
<span class="k">if</span><span class="w"> </span><span class="n">sqw_obj</span><span class="p">.</span><span class="n">pix</span><span class="p">.</span><span class="n">is_corrected</span>
<span class="w">    </span><span class="n">rlu_rev_corr</span><span class="p">.</span><span class="n">rotmat</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">sqw_obj</span><span class="p">.</span><span class="n">pix</span><span class="p">.</span><span class="n">alignment_matr</span><span class="o">&#39;</span><span class="p">;</span><span class="w"> </span><span class="c">% retrieve alignment matrix and revert it.</span>
<span class="k">end</span>
<span class="nb">clear</span><span class="w"> </span><span class="n">sqw_obj</span><span class="p">;</span>
<span class="n">change_crystal</span><span class="p">(</span><span class="n">sqw_file_name</span><span class="p">,</span><span class="n">rlu_rev_corr</span><span class="p">);</span><span class="w"> </span><span class="c">% apply original lattice and inverse orientation matrix to sqw file.</span>
</pre></div>
</div>
<p>Once you have confirmed that the alignment you have is the correct one, it is possible to fix the alignment to avoid pixel ranges calculation step mentioned above.</p>
<p id="finalize-alignment">This is done using the <code class="docutils literal notranslate"><span class="pre">finalize_alignment</span></code> function:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">wout</span><span class="p">,</span><span class="w"> </span><span class="n">rev_corr</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">finalize_alignment</span><span class="p">(</span><span class="n">win</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="s">&#39;-keep_original&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>Where:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">win</span></code> - Input filename or <code class="docutils literal notranslate"><span class="pre">sqw</span></code> object to update.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'-keep_original'</span></code> - In the case of a file-backed <code class="docutils literal notranslate"><span class="pre">sqw</span></code> object, this will avoid overwriting the original datafile and retain the temporary
file created as part of the calculation process.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">wout</span></code> - Resulting <code class="docutils literal notranslate"><span class="pre">sqw</span></code> object to which the alignment was applied. If input was kept in file or was filebacked, the object will be filebacked.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rev_corr</span></code> - A corresponding <code class="docutils literal notranslate"><span class="pre">crystal_alignment_info</span></code> to be able to reverse the alignment excluding lattice changes. It contains inverted pixels alignment matrix and new lattice
because you can not retrieve this information from pixels alignment matrix after applying <code class="docutils literal notranslate"><span class="pre">change_crystal</span></code>.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You must have attached the alignment to the <code class="docutils literal notranslate"><span class="pre">sqw</span></code> through the <code class="docutils literal notranslate"><span class="pre">change_crystal</span></code> function prior to applying it, as it will do nothing otherwise.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you use <code class="docutils literal notranslate"><span class="pre">'-keep_original'</span></code> you may wish to <code class="docutils literal notranslate"><span class="pre">save</span></code> your resulting file-backed object as the temporary file will be cleared when the
<code class="docutils literal notranslate"><span class="pre">wout</span></code> object goes out of scope. (see: file_backed_objects)</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Finalize alignment of large <code class="docutils literal notranslate"><span class="pre">sqw</span></code> object may take substantial time. The time may be even bigger than regenerating this file from scratch as parallel
generation is currently possible for <code class="docutils literal notranslate"><span class="pre">sqw</span></code> files generation but not yet implemented for <code class="docutils literal notranslate"><span class="pre">finalize_alignment</span></code> algorithm. Option 2 below is recommended to use
to finalize alignment in Horace-4.</p>
</div>
</section>
<section id="option-2-calculate-goniometer-offsets-for-regeneration-of-sqw-file-s">
<h3><span class="section-number">4.3.2. </span>Option 2 : calculate goniometer offsets for regeneration of sqw file(s)<a class="headerlink" href="#option-2-calculate-goniometer-offsets-for-regeneration-of-sqw-file-s" title="Permalink to this heading"></a></h3>
<p>In this case there is a single routine to calculate the new goniometer offsets, that can then be used in future sqw file generation.</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">alatt</span><span class="p">,</span><span class="w"> </span><span class="n">angdeg</span><span class="p">,</span><span class="w"> </span><span class="n">dpsi_deg</span><span class="p">,</span><span class="w"> </span><span class="n">gl_deg</span><span class="p">,</span><span class="w"> </span><span class="n">gs_deg</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">crystal_pars_correct</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">alatt0</span><span class="p">,</span><span class="w"> </span><span class="n">angdeg0</span><span class="p">,</span><span class="w"> </span><span class="n">omega0_deg</span><span class="p">,</span><span class="w"> </span><span class="n">dpsi0_deg</span><span class="p">,</span><span class="w"> </span><span class="n">gl0_deg</span><span class="p">,</span><span class="w"> </span><span class="n">gs0_deg</span><span class="p">,</span><span class="w"> </span><span class="n">alignment_info</span><span class="p">,</span><span class="w"> </span><span class="o">&lt;</span><span class="n">keyword</span><span class="w"> </span><span class="n">options</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<p>The inputs are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">u</span></code>, <code class="docutils literal notranslate"><span class="pre">v</span></code> - Two 3-vectors which were used to define the notional scattering plane before any alignment corrections
were performed.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">u</span></code> is usually defined as the vector of the incident beam and <code class="docutils literal notranslate"><span class="pre">v</span></code> is coplanar with respect to the instrument.</p>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">alatt0</span></code>, <code class="docutils literal notranslate"><span class="pre">angdeg0</span></code> - The initial sample lattice parameters, before refinement</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">omega0_deg</span></code>, <code class="docutils literal notranslate"><span class="pre">dpsi0_deg</span></code>, <code class="docutils literal notranslate"><span class="pre">gl0_deg</span></code>, <code class="docutils literal notranslate"><span class="pre">gs0_deg</span></code> - The initial goniometer offsets, before refinement (all in
<span class="math notranslate nohighlight">\(^\circ\)</span>)</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><span class="math notranslate nohighlight">\(\text{d}\psi\)</span>, <span class="math notranslate nohighlight">\(g_l\)</span> and <span class="math notranslate nohighlight">\(g_s\)</span> refer to the Euler angles relative to the scattering plane. Naming
conventions may differ in other notations, e.g. <span class="math notranslate nohighlight">\(\theta, \phi, \chi\)</span>.</p>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">alignment_info</span></code> - The <code class="docutils literal notranslate"><span class="pre">crystal_alignment_info</span></code> object determined above.</p></li>
</ul>
<p>The keywords options are:</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Normally keywords options need not be given and the inputs <code class="docutils literal notranslate"><span class="pre">u</span></code>, <code class="docutils literal notranslate"><span class="pre">v</span></code> and <code class="docutils literal notranslate"><span class="pre">omega0_deg</span></code> will be used.</p>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">u_new</span></code>, <code class="docutils literal notranslate"><span class="pre">v_new</span></code> - <span class="math notranslate nohighlight">\(\vec{u}\)</span>, <span class="math notranslate nohighlight">\(\vec{v}\)</span> that define the scattering plane. <span class="math notranslate nohighlight">\(d\psi\)</span>,
<span class="math notranslate nohighlight">\(g_{l}\)</span>, <span class="math notranslate nohighlight">\(g_{s}\)</span> will be calculated with respect to these vectors. (Default: <code class="docutils literal notranslate"><span class="pre">u</span></code>, <code class="docutils literal notranslate"><span class="pre">v</span></code> respectively)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">omega_new</span></code> - Value for the orientation of the virtual goniometer arcs. <span class="math notranslate nohighlight">\(d\psi\)</span>,
<span class="math notranslate nohighlight">\(g_{l}\)</span>, <span class="math notranslate nohighlight">\(g_{s}\)</span> will be calculated with respect to this offset angle. (Default: <code class="docutils literal notranslate"><span class="pre">omega</span></code>) (<span class="math notranslate nohighlight">\(^\circ\)</span>)</p></li>
</ul>
<p>The outputs are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">alatt,</span> <span class="pre">angdeg</span></code> - The true lattice parameters: <span class="math notranslate nohighlight">\([a_{true},b_{true},c_{true}]\)</span>,
<span class="math notranslate nohighlight">\([\alpha_{true},\beta_{true},\gamma_{true}]\)</span> (in Å and <span class="math notranslate nohighlight">\(^\circ\)</span> respectively)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dpsi_deg,</span> <span class="pre">gl_deg,</span> <span class="pre">gs_deg</span></code> - Misorientation angles of the vectors <code class="docutils literal notranslate"><span class="pre">u_new</span></code> and <code class="docutils literal notranslate"><span class="pre">v_new</span></code> (all in <span class="math notranslate nohighlight">\(^\circ\)</span>)</p></li>
</ul>
<p>Use the information, obtained from this routine as additional input to <code class="docutils literal notranslate"><span class="pre">gen_sqw</span></code> algorithm.</p>
</section>
<section id="option-2a-calculate-the-true-u-and-v-for-your-misaligned-crystal">
<h3><span class="section-number">4.3.3. </span>Option 2a : calculate the true u and v for your misaligned crystal<a class="headerlink" href="#option-2a-calculate-the-true-u-and-v-for-your-misaligned-crystal" title="Permalink to this heading"></a></h3>
<p>This option is not recommended for use with Horace as goniometer offsets is preferred option to align <code class="docutils literal notranslate"><span class="pre">sqw</span></code> data. Some older programs (e.g. Mslice) may not give access to goniometer, so changing <code class="docutils literal notranslate"><span class="pre">u</span></code> and <code class="docutils literal notranslate"><span class="pre">v</span></code> may be the only way to align the data, or you may be just interested in actual beam direction with respect to crystal orientation.</p>
<p>Following option 2 above, you can recalculate the true <code class="docutils literal notranslate"><span class="pre">u</span></code> and <code class="docutils literal notranslate"><span class="pre">v</span></code> vectors with the following method:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">u_true</span><span class="p">,</span><span class="w"> </span><span class="n">v_true</span><span class="p">,</span><span class="w"> </span><span class="n">rlu_corr</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">uv_correct</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">alatt0</span><span class="p">,</span><span class="w"> </span><span class="n">angdeg0</span><span class="p">,</span><span class="w"> </span><span class="n">omega_deg</span><span class="p">,</span><span class="w"> </span><span class="n">dpsi_deg</span><span class="p">,</span><span class="w"> </span><span class="n">gl_deg</span><span class="p">,</span><span class="w"> </span><span class="n">gs_deg</span><span class="p">,</span><span class="w"> </span><span class="n">alatt_true</span><span class="p">,</span><span class="w"> </span><span class="n">angdeg_true</span><span class="p">)</span>
</pre></div>
</div>
<p>The inputs are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">u</span></code>, <code class="docutils literal notranslate"><span class="pre">v</span></code> - the orientation of the correctly aligned crystal.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">alatt</span></code>, <code class="docutils literal notranslate"><span class="pre">angdeg</span></code> - the lattice parameters of the aligned crystal, i.e. the output of <code class="docutils literal notranslate"><span class="pre">crystal_pars_correct</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">omega_deg</span></code>, <code class="docutils literal notranslate"><span class="pre">dpsi_deg</span></code>, <code class="docutils literal notranslate"><span class="pre">gl_deg</span></code>, <code class="docutils literal notranslate"><span class="pre">gs_deg</span></code> - the calculated misorientation angles, i.e. the output of
<code class="docutils literal notranslate"><span class="pre">crystal_pars_correct</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">alatt_true</span></code>, <code class="docutils literal notranslate"><span class="pre">angdeg_true</span></code> - similarly, the calculated correct lattice parameters</p></li>
</ul>
<p>The outputs are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">u_true,</span> <span class="pre">v_true</span></code> - the corrected <span class="math notranslate nohighlight">\(\vec{u}\)</span> and <span class="math notranslate nohighlight">\(\vec{v}\)</span> for e.g. Mslice.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rlu_corr</span></code> - the orientation correction matrix to go from the notional to the real crystal (see above)</p></li>
</ul>
</section>
</section>
<section id="list-of-alignment-correction-routines">
<h2><span class="section-number">4.4. </span>List of alignment correction routines<a class="headerlink" href="#list-of-alignment-correction-routines" title="Permalink to this heading"></a></h2>
<p>Below we provide a brief summary of the routines available for different aspects of alignment corrections. For further information type</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="nb">help</span><span class="w"> </span><span class="o">&lt;</span><span class="k">function</span><span class="w"> </span><span class="n">name</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>in the Matlab command window.</p>
<section id="id1">
<h3><span class="section-number">4.4.1. </span>bragg_positions<a class="headerlink" href="#id1" title="Permalink to this heading"></a></h3>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">rlu0</span><span class="p">,</span><span class="nb">width</span><span class="p">,</span><span class="n">wcut</span><span class="p">,</span><span class="n">wpeak</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">bragg_positions</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="n">rlu</span><span class="p">,</span><span class="w"> </span><span class="n">radial_cut_length</span><span class="p">,</span><span class="w"> </span><span class="n">radial_bin_width</span><span class="p">,</span><span class="w"> </span><span class="n">radial_thickness</span><span class="p">,</span><span class="k">...</span>
<span class="w">                                          </span><span class="n">trans_cut_length</span><span class="p">,</span><span class="w"> </span><span class="n">trans_bin_width</span><span class="p">,</span><span class="w"> </span><span class="n">trans_thickness</span><span class="p">)</span>
</pre></div>
</div>
<p>Get actual Bragg peak positions, given initial estimates of their positions, from an sqw object or file</p>
</section>
<section id="bragg-positions-view">
<h3><span class="section-number">4.4.2. </span>bragg_positions_view<a class="headerlink" href="#bragg-positions-view" title="Permalink to this heading"></a></h3>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">bragg_positions_view</span><span class="p">(</span><span class="n">wcut</span><span class="p">,</span><span class="w"> </span><span class="n">wpeak</span><span class="p">)</span>
</pre></div>
</div>
<p>View the output of fitting to Bragg peaks performed by <code class="docutils literal notranslate"><span class="pre">bragg_positions</span></code></p>
</section>
<section id="crystal-pars-correct">
<h3><span class="section-number">4.4.3. </span>crystal_pars_correct<a class="headerlink" href="#crystal-pars-correct" title="Permalink to this heading"></a></h3>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">alatt</span><span class="p">,</span><span class="w"> </span><span class="n">angdeg</span><span class="p">,</span><span class="w"> </span><span class="n">dpsi_deg</span><span class="p">,</span><span class="w"> </span><span class="n">gl_deg</span><span class="p">,</span><span class="w"> </span><span class="n">gs_deg</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">crystal_pars_correct</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">alatt0</span><span class="p">,</span><span class="w"> </span><span class="n">angdeg0</span><span class="p">,</span><span class="w"> </span><span class="n">omega0_deg</span><span class="p">,</span><span class="w"> </span><span class="n">dpsi0_deg</span><span class="p">,</span><span class="w"> </span><span class="n">gl0_deg</span><span class="p">,</span><span class="w"> </span><span class="n">gs0_deg</span><span class="p">,</span><span class="w"> </span><span class="n">al_info</span><span class="p">)</span>
</pre></div>
</div>
<p>Return correct lattice parameters and crystal orientation for gen_sqw from a matrix that corrects the r.l.u.</p>
</section>
<section id="refine-crystal">
<h3><span class="section-number">4.4.4. </span>refine_crystal<a class="headerlink" href="#refine-crystal" title="Permalink to this heading"></a></h3>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">al_info</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">refine_crystal</span><span class="p">(</span><span class="n">rlu0</span><span class="p">,</span><span class="w"> </span><span class="n">alatt0</span><span class="p">,</span><span class="w"> </span><span class="n">angdeg0</span><span class="p">,</span><span class="w"> </span><span class="n">bragg_peaks</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">fix_</span><span class="p">])</span>
</pre></div>
</div>
<p>Refine crystal orientation and lattice parameters</p>
</section>
<section id="ubmatrix">
<h3><span class="section-number">4.4.5. </span>ubmatrix<a class="headerlink" href="#ubmatrix" title="Permalink to this heading"></a></h3>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">ub</span><span class="p">,</span><span class="w"> </span><span class="n">mess</span><span class="p">,</span><span class="w"> </span><span class="n">umat</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">ubmatrix</span><span class="w"> </span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>Calculate UB matrix that transforms components of a vector given in r.l.u. into the components in an orthonormal frame
defined by the two vectors u and v (each given in r.l.u)</p>
</section>
<section id="uv-correct">
<h3><span class="section-number">4.4.6. </span>uv_correct<a class="headerlink" href="#uv-correct" title="Permalink to this heading"></a></h3>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">u_true</span><span class="p">,</span><span class="w"> </span><span class="n">v_true</span><span class="p">,</span><span class="w"> </span><span class="n">rlu_corr</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">uv_correct</span><span class="w"> </span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">alatt0</span><span class="p">,</span><span class="w"> </span><span class="n">angdeg0</span><span class="p">,</span><span class="w"> </span><span class="n">omega_deg</span><span class="p">,</span><span class="w"> </span><span class="n">dpsi_deg</span><span class="p">,</span><span class="w"> </span><span class="n">gl_deg</span><span class="p">,</span><span class="w"> </span><span class="n">gs_deg</span><span class="p">,</span><span class="w"> </span><span class="n">alatt_true</span><span class="p">,</span><span class="w"> </span><span class="n">angdeg_true</span><span class="p">)</span>
</pre></div>
</div>
<p>Calculate the correct u and v vectors for a misaligned crystal, for use e.g. with Mslice.</p>
</section>
<section id="rlu-corr-to-lattice">
<h3><span class="section-number">4.4.7. </span>rlu_corr_to_lattice<a class="headerlink" href="#rlu-corr-to-lattice" title="Permalink to this heading"></a></h3>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">alatt</span><span class="p">,</span><span class="n">angdeg</span><span class="p">,</span><span class="n">rotmat</span><span class="p">,</span><span class="n">ok</span><span class="p">,</span><span class="n">mess</span><span class="p">]=</span><span class="n">rlu_corr_to_lattice</span><span class="p">(</span><span class="n">rlu_corr</span><span class="p">,</span><span class="n">alatt0</span><span class="p">,</span><span class="n">angdeg0</span><span class="p">)</span>
</pre></div>
</div>
<p>Extract lattice parameters and orientation matrix from r.l.u correction matrix and reference lattice parameters</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Data_diagnostics.html" class="btn btn-neutral float-left" title="3. Data diagnostics" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Cutting_data_of_interest_from_SQW_files_and_objects.html" class="btn btn-neutral float-right" title="5. Cutting data of interest from SQW files and objects" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2006-2025, STFC RAL.
      <span class="lastupdated">Last updated on Jan 16, 2025, 6:47:24 PM.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
  
<br><br>
<a href="https://github.com/pace-neutrons/Horace/edit/master/documentation/user_docs/docs/manual/Correcting_for_sample_misalignment.rst">Click here to edit</a> or <a href="https://github.com/pace-neutrons/Horace/edit/master/documentation/user_docs/docs/new_page.rst">Click here to add new page</a> (requires <a href="https://github.com/login">GitHub account</a>).
<br>
For more info on editing <a href="../Contributing.html">click here</a>.


</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>