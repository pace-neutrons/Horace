classdef hlp_serial_types

    properties(Constant)
        % Names or distinguisable types of the classes we can encounter and
        % would deal with separately
        types =...
            {'logical', 'char', 'string', 'double',...
            'single', 'int8', 'uint8', 'int16', 'uint16', 'int32', 'uint32',...
            'int64', 'uint64', 'complex_double', 'complex_single', 'complex_int8',...
            'complex_uint8', 'complex_int16', 'complex_uint16', 'complex_int32',...
            'complex_uint32', 'complex_int64', 'complex_uint64', 'cell', 'struct',...
            'function_handle', 'value_object', 'handle_object_ref', 'enum',...
            'sparse_logical', 'sparse_double', 'sparse_complex_double',...
            'serializable'};
        % Tags of the classes, used instead of names in the serialized data
        % stream
        tags = cellfun(@uint8, num2cell(0:32), 'UniformOutput', false);

        % Sizes of respective simple data types. Complex data types are calculated
        % during serialization so their basic type is 0;
        data_size = ...
            {1, 1, 2, 8,...          %      'logical', 'char', 'string', 'double',...
            4, 1, 1, 2, 2, 4, 4,...  %      'single', 'int8', 'uint8', 'int16', 'uint16', 'int32', 'uint32',...
            8, 8, 16, 8, 2, ...      %      'int64', 'uint64', 'complex_double', 'complex_single', 'complex_int8',...
            2, 4, 4, 8,...           %      'complex_uint8', 'complex_int16', 'complex_uint16', 'complex_int32',...
            8, 16, 16, 0, 0, ...     %      'complex_uint32', 'complex_int64', 'complex_uint64', 'cell', 'struct',...
            0, 0,  0,  0, ...        %      'function_handle', 'value_object', 'handle_object_ref', 'enum',...
            1, 8, 16,...             %      'sparse_logical', 'sparse_double', 'sparse_complex_double'
            0},...                   %      'serializable' -- object serializes itself

        % function handle type constist of common tag and subtag combined
        % within a single byte
        func_handle_types ={'any_other','simple', 'classsimple','anonymous','scopedfunction','nested'}
        func_handle_tags  ={0,          64,           64,          128,         192,          192  }
        fh_map = containers.Map(hlp_serial_types.func_handle_types ,...
            hlp_serial_types.func_handle_tags)

        % Details associated with the type
        type_details = struct(...
            'name',  hlp_serial_types.types,...
            'size',  hlp_serial_types.data_size,...
            'tag',   hlp_serial_types.tags... % Lookup tags for type of serialized data,
            );


        % Lookup map used for binding between names and type_details
        % we select three topmost bits for keeping information about
        % function handle type, so there are only 63 other types available
        lookup = containers.Map(hlp_serial_types.types,1:33);

        % Helper map, binding types and their tags directly
        tags_map = containers.Map(hlp_serial_types.types ,...
            hlp_serial_types.tags)

        tag_size = 2;  % Size of standard tag (uint8) in bytes
        ndims_size = 1;% Size of standard num dimensions (uint8) in bytes
        dim_size   = 4;  % Size of standard dimension (uint32) in bytes
    end

    methods(Static)
        function details = get_details(type)
            details = hlp_serial_types.type_details(hlp_serial_types.lookup(type));
        end

        function tag = dims_tag(nDims)
            % dim tag is just character representation of number of
            % dimensions (fom 0 to 255)
            tag  = uint8(nDims);
        end

        function size = get_size(type)
            size = hlp_serial_types.type_details(hlp_serial_types.lookup(type)).size;
        end

        function cont = contains(type)
            cont = isKey(hlp_serial_types.lookup, type);
        end

        function objID_struc = type_mapping(v)
            type = class(v);
            if isa(v,'serializable')
                objID_struc = hlp_serial_types.get_details('serializable');
                return
            end

            if isnumeric(v) && ~isreal(v)
                type = ['complex_' type];
            end
            if issparse(v)
                type = ['sparse_' type];
            end

            if isKey(hlp_serial_types.lookup, type)
                objID_struc = hlp_serial_types.get_details(type);
            elseif ishandle(v)
                objID_struc = hlp_serial_types.get_details('handle_object');
            else
                objID_struc = hlp_serial_types.get_details('value_object');
            end
        end

        function [type_str, nDims,size_or_fhid,pos] = unpack_data_tag(head_bytes,pos)
            % unpack data tag, previously generated by pack_data_tag
            % function
            % Inputs:
            % head_bytes -- array of the bytes, containing header
            %               information
            % pos -- starging position of the header information in the
            %        array
            % Returns:
            % type_str   -- the structure, describing the selected data
            %               type
            % nDims      -- number of dimensions of the type
            % size_or_fhid-- the array of size and shape of the encoded
            %               object.
            %            -- As function handle is always size 1, this
            %               field contains the type of the function handle
            %               code if type of header is a function_handle
            % pos
            tag = uint8(head_bytes(pos));

            % ugly. But optimization is always ugly.
            if tag>63 || tag == 25 % function handle specific types.
                fh_tag = bitand(tag,uint8(192));
                tag    = tag-fh_tag;
                type_str = hlp_serial_types.type_details(tag + 1);
                nDims=1;
                size_or_fhid =double(fh_tag);
                pos = pos+1;
                return;
            end

            type_str = hlp_serial_types.type_details(tag + 1);
            nDims = double(head_bytes(pos+1));
            pos = pos + 2;
            if nDims == 0
                size_or_fhid = [];
            elseif nDims == 1
                nElem = double(typecast(head_bytes(pos:pos+3), 'uint32'));
                size_or_fhid = [1,nElem];
                pos = pos+4;
            else
                nBytes = nDims*4;
                size_or_fhid   = double(typecast(head_bytes(pos:pos+nBytes-1), 'uint32')');
                pos    = pos+nBytes;
            end

        end

        function comb_tag = pack_data_tag(data_size,type_struc,varargin)
            % Pack tag data into different size bytestring, with actual
            % size depending on the size and shape of the data.
            %
            % Inputs:
            % data_size  -- size of the appropriate array
            % type_struc -- the structure, describing the data type, the
            %               header is preparted for
            % varargin   -- additional information on the type of the function
            %               handle to process or indicator to write full data.
            %               header, used for preparing full data header in
            %               case of sparse data.
            %               Ignored in all other cases.
            %
            % Returns:
            % comb_tag  --  byte-array, describing the type, consisting of
            %               first byte -- tag, defining the data type to convert,
            %               second byte -- nuber of dimensions,
            %               other bytes, if present, contain uint8(data_size)
            %               It is absent if second byte is 0 or may
            %               be reduced if it is 1)
            % comb_tag for function_handle and sparse types is different
            %
            % function_handle always single so no point of having
            %              dimensions for it. Its tag consists of single
            %              byte, encoding function handle and its types
            %
            %
            tag = type_struc.tag;

            nDims = numel(data_size);
            if isempty(data_size)
                nElem = 0;
            else
                nElem = prod(data_size);
            end

            % A bit of ugliness, to deal with special cases which takes
            % too many changes to fix
            if tag == hlp_serial_types.tags_map('function_handle') %
                func_type = varargin{1};
                if ~ismember(func_type,hlp_serial_types.func_handle_types)
                    func_type = 'any_other';
                end
                comb_tag = type_struc.tag+hlp_serial_types.fh_map(func_type);
                return % function handle does not have dimensions
            end

            % all other cases
            if nElem == 0
                comb_tag = [tag;hlp_serial_types.dims_tag(0)];
            elseif nElem == 1  && nargin == 2 % avoid writing 2 dimensions for scalars
                comb_tag = [tag;hlp_serial_types.dims_tag(1);...
                    typecast(uint32(1),'uint8')'];
            elseif nDims == 2 && data_size(1) == 1 && nargin == 2
                % some saving in writing rows if 2D array arranged in rows.
                % If this incorrect, use general case.
                comb_tag = [tag;hlp_serial_types.dims_tag(1);...
                    typecast(uint32(nElem),'uint8')'];
            else
                comb_tag = [tag;hlp_serial_types.dims_tag(nDims);...
                    typecast(uint32(data_size),'uint8')'];
            end
        end

        function tag_size = calc_tag_size(data_size,type_struc,varargin)
            % find size of a data tag depending on the size and shape of the data
            %
            if strcmp(type_struc.name,'function_handle') %
                tag_size = 1;
                return;
            end

            nDims = numel(data_size);
            if isempty(data_size)
                nElem = 0;
            else
                nElem = prod(data_size);
                dim_size = hlp_serial_types.dim_size;
            end

            if nElem == 0
                tag_size = hlp_serial_types.tag_size;
            elseif nElem == 1&& nargin == 2 % avoid writing 2 dimensions for scalars
                tag_size = hlp_serial_types.tag_size+dim_size;
            elseif nDims == 2 && data_size(1) == 1 && nargin == 2
                % some saving in writing rows if incoming 2D arrays
                % are rows. Go to general case otherwise
                tag_size = hlp_serial_types.tag_size+dim_size ;
            else
                tag_size = hlp_serial_types.tag_size+dim_size*numel(data_size);
            end
        end

    end

end
